# Java

## Java基础

### 作用域与可见性

| 作用域与可见性 | 当前类 | 同一package | 子类 | 其他package |
| -------------- | ------ | ----------- | ---- | ----------- |
| public         | √      | √           | √    | √           |
| protected      | √      | √           | √    |             |
| default        | √      | √           |      |             |
| private        | √      |             |      |             |

### 重载和重写

|            | 重载     | 重写                                 |
| ---------- | -------- | ------------------------------------ |
| 发生范围   | 同一个类 | 子类中                               |
| 参数列表   | 必须修改 | 一定不能修改                         |
| 返回类型   | 可修改   | 一定不能修改                         |
| 异常       | 可修改   | 可以减少或删除,不能抛出更多的异常    |
| 访问修饰符 | 可修改   | 可以降低修饰级别, 不能做更严格的限制 |
| 发生阶段   | 编译期   | 运行期                               |

### 面向对象的特性

- 封装
- 继承：子类拥有父类对象所有的属性和方法（但是无法访问父类的私有属性和方法）。因为在一个子类被创建时，首先会在内存中创建一个父类对象，然后在父类对象外部放上子类独有的属性，两者结合起来形成一个子类对象。
- 多态：程序中定义的引用变量所指向的具体类型和通过该引用变量的方法调用,在编程的时候是不确定的,只有运行期间才是确定的. 也就是引用变量指向哪一个实例对象,在编译期间是不确定的,只有在运行期才确定.

编译器多态:  比如重载

运行期多态:  比如重写

### Java中无参构造方法的作用

- Java在执行子类的构造方法之前, 如果没有采用 `super` 调用父类特定的构造方法, 就会调用父类中的 "无参构造方法"
- 如果父类中只定义了有参的构造方法, 而在子类中又没有使用 `super` 来调用父类中指定的构造方法, 则在编译时会发生错误, 因为找不到父类的无参构造方法
- 所以需要在父类中加上一个无参构造方法

### new String("abc")

- JVM检查字符串常量池中是否存在 "abc" 字符串
- 如果不存在，则现在字符串常量池中创建 "abc"
- 在堆内存中创建一份字符串对象，拷贝字符串常量池中的 "abc" 到内存中的字符串对象中
- 返回堆内存中该字符串的内存地址

```
String str1 = "abc";
String str2 = "abc";
String str3 = new String("abc");
String str4 = new String("abc");
```

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1102741/1593915022822-8920a1cd-129f-4d04-b5d7-a0b231d04602.png)

## 异常

### error 和 exception

`Error` 和 `Exception` 类的父类都是 `Throwable` 类，主要区别如下：

- `Error` 类：主要与虚拟机相关的问题，如：系统崩溃，虚拟机错误，方法栈溢出。这将导致程序中断，依靠程序本身无法预防和恢复。
- `Exception` 类：分为运行时异常和受检查时异常

  - 运行时异常：可以编译通过但是一运行就会停止，程序不会自己处理（空指针异常、数组越界等）
  - 受检查异常：要么用 `try…catch…` 捕获，要么用 `throws` 抛出，交给父类处理

### throw 和 throws

- `throw` ：在方法体内部抛出异常，由方法体内部的语句处理；throw是具体向外抛出异常的动作，所以它抛出的是一个异常类。
- `throws` ：throws再方法后声明，表示如果抛出异常，由方法的调用者处理。（有抛出异常的可能性，但是并不一定会抛出异常）

## 泛型

- Java泛型设计原则：只要编译期没有出现警告，那么在运行期就不会出现ClassCastException异常
- 定义：把类型明确的工作推迟到创建对象或调用方法的时候才回去确定的特殊类型
- 只作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦除，还是原来最基本的类型

```
List list = new ArrayList();
//泛型，参数化类型。通过反射可以越过泛型检查
List<String> list = new ArrayList<String>();
```

**泛型类型在逻辑上可以看成是多个不同的类型，实际上都是相同的基本****类型** 

```
public class GenericTest{
    public static void main(String[] args){
        Box<String> name = new Box<String>("hg");
        Box<Integer> age = new Box<Integer>(10);
        System.out.println(name.getClass());    //com.Box
        System.out.println(name.getClass()==age.getClass());   //true
    }
}
class Box<T>{
    …………
}
```

在使用泛型类时，虽然传入了不同的泛型实参，但是并没有真正意义上生成不同的类型，传入不同泛型实参的泛型类在内存上只有一个，还是原来最基本的类型

## 反射

Java反射机制就是在运行状态中

- 对于任意一个类，都能知道这个类的所有属性和方法
- 对于任意一个对象，都能调用它的任意一个方法和属性

这种**动态获取的信息**以及 **动态调用对象的方法**的功能被称为java语言的反射机制

### 反射的原理与class对象

![img](https://cdn.nlark.com/yuque/0/2020/png/1102741/1594002038863-8f4aa082-b22a-4260-bbf5-bb438c5aa1a5.png)

`Class` 类的实例表示正在运行的 Java 应用程序中的类和接口。也就是jvm中有N多的实例每个类都有该Class对象。（包括基本数据类型）

### 反射的使用

**获取Class对象** 

```
//第一种，已经得到对象了，就不必使用反射
Student stu1 = new Student();
Class stuClass = stu1.getClass();
System.out.println(stuClass.getName());
//需要导入依赖，依赖性太强
Class stuClass2 = Student.class;
System.out.println(stuClass2.getName());
System.out.println(stuClass2.equals(stuClass));
//最常用，带包名的路径
try {
    Class stuClass3 = Class.forName("JVM.Reflect.Student");
    System.out.println(stuClass3 == stuClass2);
}catch (ClassNotFoundException e){
    e.printStackTrace();
}
```

**获取构造方法** 

```
//加载class对象
Class clazz = Class.forName("JVM.Reflect.Student");
//所有"公有的"构造方法
Constructor[] conArray = clazz.getConstructors();
//获取所有的构造方法(包括私有、受保护、默认、公有)
Constructor[] conArray = clazz.getDeclaredConstructors();
//获取单个的"公有的"构造方法（参数类型）
Constructor con = clazz.getConstructor(null);
//获取"某个构造方法"可以是私有的，或受保护、默认、公有；
Constructor con = clazz.getDeclaredConstructor(char.class);
```

**获取成员变量** 

```
//获取Class对象
Class stuClass = Class.forName("JVM.Reflect.Student");

//获取所有公有字段
Field[] fields = stuClass.getFields();

//获取所有字段
Field[] fields = stuClass.getDeclaredFields();

//获取某个共有字段
Field f = stuClass.getField("name");
//调用构造方法创建新实例
Object object = stuClass.getConstructor().newInstance();
//设置字段值
f.set(object, "刘德华");
//新建student对象
Student student = (Student)object;
System.out.println(student.name);

//获取某个私有字段
Field f = stuClass.getDeclaredField("phoneNum");

//获取父类中的字段（以下的方法也是类似的）
//先获取父类，再获取字段（方法）
Field[] field = stuClass.getSuperclass().getDeclaredFields();
```

**获取成员方法** 

```
//获取class对象
Class stuClass = Class.forName("JVM.Reflect.Student");
//获取所有公有方法
Method[] methods = stuClass.getMethods();
//获取所有方法
Method[] methods = stuClass.getDeclaredMethods();

//获取某个公有方法（方法名，参数类型）
Method m = stuClass.getMethod("show1", String.class);
//新建实例对象
Object object = stuClass.getConstructor().newInstance();
//invoke就是调用method的方法，在这里就是调用m方法
m.invoke(object,"刘德华");

//获取某个私有方法（方法名，参数类型）
Method m = stuClass.getDeclaredMethod("show4", int.class);
```

**越过泛型检查** 

这是因为泛型检查是在编译时期进行的，也就是说编译后的add()方法其实和没有指定泛型的add()方法是一致的，都是没有进行泛型检查的。所以通过反射获取ArrayList的Class文件对象中的add()方法,在调用该add()方法时是不用泛型检查的。

```
public static void fanxing() throws Exception{
    ArrayList<String> strList = new ArrayList<>();
    strList.add("aaa");
    strList.add("bbb");
    Class listClass = strList.getClass();
    Method method = listClass.getMethod("add", Object.class);
    method.invoke(strList, "100");
    for (Object obj : strList)
        System.out.println(obj);
}
```

## Java集合

- Collection

  - List

  - Vector：线程安全
    - ArrayList
    - LinkedList：双向链表

  - Queue

    - LinkedList
    - PriorityQueue：基于堆结构实现，可以用来实现优先队列

  - Set

    - HashSet：无序
    - TreeSet：支持有序操作，查找效率不如HashSet

- Map

  - HashMap：基于哈希表
  - TreeMap：基于红黑树

### HashMap

#### 为什么hashmap的长度要为2^n大小

因为hash值的取值范围是 -2^31 ~ 2^31-1，但是内存中放不下这么大的数组，所以得到的散列值还需要对数组的长度进行取余运算，这个数组下标计算的方法就是 （n-1）& hash。

**为了提高取余操作的效率** 

x % 2^n = x & (2^n-1)

为什么两者相等：

- 如果对2^n取余，从二进制的角度来看，就是得到 0 - n-1位的值，因为n位之后的都是2^n的倍数
- 2^n-1 保证了 0 - n-1 位都是1，和别的数做 & 运算，得到的就是 0 - n-1 位的值

#### hashmap扩容问题

每次扩容都是容量翻倍

当把table[i]中的所有node都迁移到newtab中的时候（原表大小为n）

- 如果 hash&n==0，则该node的位置不变
- 如果 hash&n==1，则该node的位置+n

为什么会是直接+n，这和hashmap的取余操作有关系。

假设扩容前 n为a位，n-1的低a-1位都为1，hash&n就是hash值的低a-1位

扩容之后 n变成a+1位，n-1的低a位都是1，hash&n就是hash值的低a位

这样看来，两者的差别就只有hash值第a位

- 如果hash值的第a位为0，那么扩容之后位置不变
- 如果hash值的第a位为1，那么扩容之后位置+n

#### 为什么HashMap的value可以为空，HashTable和ConcurrentHasMmap的val都不为空

因为HashMap的value可以为空，所以HashMap不可以通过get()方法来判断某个元素是否存在。

- 因为返回null的时候，可能是因为这个key对应的value就是null；也可能因为key不存在、
- 所以需要使用contains来判断元素是否存在

```
if(map.contains(k))
    map.get(k);
else
    throw new KeyNotPresentException();
```

在多线程的条件下，可能在contians判断之后，另一个线程可能会把这个key删除

然后再用get得到的值就会为空，就可能出现并发问题

如果不允许value为空的话，就可以使用get来判断map是否包含该key，这样就没有了并发问题

# 多线程

## 双重检验锁实现单例模式

```
public class DoubleCheck{
    private volatile static DoubleCheck instance;
    private DoubleCheck(){}
    private synchronized static DoubleCheck getInstance(){
        //先判断对象是否已经实例过,没有实例化过才进去加锁代码
        if(instance==null){
            synchronized(DoubleCheck.class){
                if(instance==null){
                    instance = new DoubleCheck();
                }
            }
        }
        return instance;
    }
}
```

使用 `volatile` 修饰 `instance` 是为了防止指令重排,  因为 `instance = new DoubleCheck()` 分为三步来执行

- 为 `instance` 分配内存空间
- 初始化 `instance` 
- 将 `instance` 指向分配的内存地址

如果在多线程的环境下,执行顺序变为1->3->2的话,  线程T1执行了1和3, 此时T2调用 `getInstance()` 发现 `instance` 不为空,因此会返回 `instance` ,但是此时 `instance` 还未被初始化

## 线程间通信

### 关键字

1. volatile 关键字
   * 告知程序所有对该变量的访问，都需从共享内存中获取；所有对它的改变，都需要同步刷新回共享内存，保证所有线程对变量访问的可见性
   * 过多的使用 volatile 关键字，会降低程序执行效率
2. synchronization 关键字
   * 保证多个线程在同一时刻，只能有一个线程处于方法或者同步块之中
   * 保证线程对变量访问的可见性和排他性
   * 同步方法或者同步块，本质都是对 **对象的监视器** 进行获取（任何对象都有自己的监视器）

### 等待/通知机制

使用`wait() notify() notifyAll()`时需要注意的细节

* 使用这些方法之前，应该 先对调用对象 **加锁**
* 调用 `wait()` 方法后，线程状态由 `RUNNING` 变为 `WAITING`，并将当前线程放置到对象的等待队列
* `notify()` 或`notifyAll() `调用之后，等待线程不会从 `wait` 返回，需要调用`notify() notifyAll()`的线程释放锁之后，等待线程才有机会从 `wait()` 返回
* `notify()` 是将等待队列中的一个等待线程从等待队列中移动到同步队列中；`notifyAll()` 是将等到队列中的所有线程全部移动到同步队列。被移动的线程状态由 `WAITING` 变为 `BLOCKED`
* 从 `wait()` 方法返回的前提是，获得了调用对象的锁

### 等待/通知经典范式

等待方：

* 获取对象锁

* 如果条件不满足，调用对象的`wait()`方法，被通知后仍要检查条件

* 条件满足则执行对应的逻辑

  ```java
  synchronized(对象){
      while(条件不满足){
          对象.wait();
      }
      对应的处理逻辑
  }
  ```

通知方：

* 获得对象的锁

* 改变条件

* 通知所有等待在对象上的线程

  ```java
  synchronized(对象){
      改变条件;
      对象.notifyAll();
  }
  ```

  

### 管道输入/输出流

管道输入/输出流：用于线程之间的数据传输，传输的媒介为内存

* `PipedOutputStream、PipedInputStream`：面向字节

* `PipedReader、PipedWriter`：面向字符

  ```java
  PipedWriter out = new PipedWriter();
  PipedReader in = new PipedReader();
  //输入流和输出流进行连接
  out.connect(in);
  ……
  //写数据
  out.write(数据);
  
  new Thread -> run(){
      //读数据
      in.read();
  }
  ```

### Thread.join

线程A执行 `thread.join()`语句：当前线程 A 等待 Thread 线程终止之后才会从 `thread.join()` 返回

```java
public final synchronized void join() throws InterruptedException{
    //条件不满足，继续等待
    while(isAlive()){
        wait(0);
    }
    //条件符合，方法返回
}
```

### ThreadLocal

线程变量：ThreadLocal为键、任意对象为值 的存储结构

## CountDownLatch和Thread.join()

### CountDownLatch

`countDownLatch` 像是一个计数器，线程完成一个记录一个，计数器递减，只能使用一次。

可以用来控制线程按顺序执行，主要有以下几个方法：

```
//构造方法，count是计数器的初值
public CountDownLatch(int count) {};
//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行
public void await() throws InterruptedException { };   
//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行
public boolean await(long timeout, TimeUnit unit) throws InterruptedException { };  
//将count值减1
public void countDown() {};
```

### join()方法

使用 `thread.join()` 方法也可以达到控制线程，按顺序执行的目的

```
threadA.start();
threadA.join();
…………B…………
```

join的成员方法加了synchronized关键字，说明是`synchronized(this)`，this是谁啊？this就是threadA子线程对象本身。也就是说， **调用join()方法的线程** 持有了threadA这个对象的锁。

只有当子线程threadA执行完毕的时候，jvm会自动唤醒（`lock.notify_all(thread)` ）阻塞在threadA对象上的线程，才会继续执行B部分的代码。

## 新建线程的三种方式

用并发编程实现加法，主要步骤有三个

- 分解任务
- 新建线程执行子任务
- 合成子结果为最终结果

### 继承thread类（无返回值）

```
public class SumThread extends Thread {
    private long start;
    private long end;
    private int num;
    private long[] result;
    private CountDownLatch cdl;

    public SumThread(long start, long end, int num, long[] result, CountDownLatch cdl) {
        this.start = start;
        this.end = end;
        this.num = num;
        this.result = result;
        this.cdl = cdl;
    }
    //需要重写run方法
    @Override
    public void run() {
        long sum = 0;
        for (long i=start;i<end;i++){
            sum += i;
        }
        result[num] = sum;
        //计数器减一
        cdl.countDown();
    }
}
public class SumParallelThread {
    public static void main(String[] args) throws InterruptedException{
        int N = 90000000;
        int numThread = 3;
        parallel(N, numThread);
    }
    public static void parallel(int N, int numThread) throws InterruptedException{
        //通过一个数组来记录各个子线程的计算结果
        long[] result = new long[numThread];
        //CountDownLatch可以看作计数器
        CountDownLatch cdl = new CountDownLatch(numThread);
        long start = System.currentTimeMillis();
        for (int i=0;i<numThread;i++){
            //新建线程，并执行
            SumThread thread = new SumThread(i*N/numThread, (i+1)*N/numThread, i, result, cdl);
            thread.start();
        }
        //等待所有线程执行完毕，在进行最后的加法
        cdl.await();
        long sum = 0;
        for (long r : result)
            sum += r;
        long end = System.currentTimeMillis();
        System.out.println("并行计算结果："+sum);
        System.out.println("并行计算时间："+(end-start)+"ms");
    }
}
```

### 实现Runanle接口（无返回值）

```
public class SumThreadRunnable implements Runnable {
    private long start;
    private long end;
    private long[] result;
    private CountDownLatch cdl;
    private int num;
    public SumThreadRunnable(long start, long end, long[] result, CountDownLatch cdl, int num){
        this.start = start;
        this.end = end;
        this.result = result;
        this.cdl = cdl;
        this.num = num;
    }
    //重写run方法
    @Override
    public void run() {
        long sum = 0;
        for (long i=start;i<=end;i++){
            sum += i;
        }
        result[num] = sum;
        cdl.countDown();
    }
}
public class SumParallelRunnable {
    public static void main(String[] args) throws InterruptedException{
        int N = 90000000;
        int numThread = 3;
        countDownLatchSum(N, numThread);
    }
    public static void countDownLatchSum(int N, int numThread) throws InterruptedException{
        long start = System.currentTimeMillis();
        CountDownLatch cdl = new CountDownLatch(numThread);
        //和上一个一样，使用一个数组来保存子线程的计算结果
        long[] result = new long[numThread];
        long sum = 0;
        for (int i=0;i<numThread;i++){
            //runable作为target去新建线程，调用start方法执行子线程
            new Thread(new SumThreadRunnable(i*N/numThread, (i+1)*N/numThread, result, cdl, i)).start();
        }
        cdl.await();
        for (long r : result)
            sum += r;
        long end = System.currentTimeMillis();
        System.out.println("并行计算耗时："+(end-start)+"ms");
        System.out.println("并行计算结果："+sum);
    }
}
```

### 实现Callable接口和Future（有返回值）

```
public class SumThreadCallable implements Callable<Long> {
    private long start;
    private long end;
    public SumThreadCallable(long start, long end){
        this.start = start;
        this.end = end;
    }
    //重写call方法，会有返回值
    @Override
    public Long call() throws Exception {
        long sum = 0;
        for (long i=start;i<end;i++){
            sum += i;
        }
        return sum;
    }
}
public class SumParallelCallable {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        int numThread = 3;
        int N = 90000000;
        parallel(N, numThread);
    }
    public static void parallel(int N, int numThread) throws ExecutionException, InterruptedException{
        //新建线程池
        ExecutorService executor = Executors.newFixedThreadPool(numThread);
        long start1 = System.currentTimeMillis();
        //使用Future记录返回值
        List<Future<Long>> ans = new ArrayList<>();
        for (int i=0;i<numThread;i++){
            //使用submit向线程池提交线程，会有返回值
            //使用execute提交没有返回值
            Future<Long> a = executor.submit(new SumThreadCallable(i*N/numThread, (i+1)*N/numThread));
            ans.add(a);
        }
        long sum = 0;
        for (Future<Long> i : ans){
            long tmp = i.get();
            System.out.println("线程"+i+"的结果是："+tmp);
            sum += tmp;
        }
        long end1 = System.currentTimeMillis();
        System.out.println("并行计算耗时："+(end1-start1)+"ms");
        System.out.println("并行计算结果："+sum);
    }
}
```

## 线程池

### 为什么使用线程池

- 降低资源消耗 :  创建/销毁线程会有系统开销，过于频繁的创建/销毁线程，会很大程度影响处理效率
- 提高响应速度 :  线程并发数量过多，会抢占系统资源造成阻塞
- 提高线程的客观理性 :  对线程进行一些简单的管理（延迟执行、定时循环执行）

### 线程池参数

- corePoolSize：核心线程数的最大值
- maximumPoolSize：线程总数最大值
- keepAliveTime：非核心线程闲置超时时长
- TimeUnit：时间枚举类型
- BlockingQueue<Runnable>：任务队列
- ThreadFactory：创建线程的方式
- RejectedExecutionHandler：抛出异常的方式（拒绝策略）

### 线程池状态

- RUNNING：创建线程池，初始时，处在此状态
- SHUTDOWN：调用shutdown()方法，处于此状态，此时不接收新任务，但是会等待所有任务执行完毕
- STOP：调用shutdownNow()方法，处于此状态，此时不接收新任务，并且尝试终止正在执行的任务
- TIDYING：处于SHUTDOWN或STOP状态，并且所有工作线程都销毁，任务缓存队列清空或执行结束后，线程池会处在此状态
- TERMINATED：在执行 `terminated()` 方法之后会进入到此状态

### 线程提交策略

execute()：提交一个任务，没有返回值

submit()：提交一个线程任务，有返回值

`ThreadPoolExecutor.execute(Runnable command)` ：向线程池中添加一个任务

- 如果线程数未达到核心线程数，就新建核心线程来处理任务
- 如果达到核心线程数，就把把来的任务加入缓存队列中
- 如果队列已满，就新建非核心线程来执行任务
- 如果线程数达到maximumPoolSize，再进来新的任务就会抛出异常
- 如果线程数大于corePoolSize，若某线程的空闲时间大于keepAliveTime，线程就将被终止，直至线程数等于corePoolSize。如果允许为核心线程设置存活时间，那么核心线程的空闲时间大于keepAliveTime的时候，也会被终止

### 排队策略

- SynchronousQueue：这个队列不会保留任务，每次收到任务，就会直接提交给线程处理，如果所有的线程都在工作，那就会新建一个线程来处理任务。
- LinkedBlockingQueue：队列不限制长度，当接收到任务时，如果当前线程数小于核心线程数，就新建核心线程处理任务。如果当前线程数等于核心线程数，就进入队列等待，这个队列的长度没有限制，会导致maximumPoolSize失效。
- ArrayBlockingQueue：限定长度的队列，当接收到任务时，如果当前线程数小于核心线程数，就新建核心线程处理任务。如果当前线程数等于核心线程数，任务就进入等待队列，如果等待队列满了，就新建非核心线程处理任务，直到任务数达到maximumPoolSize。如果此时还有任务加入，就会抛出异常
- DelayQueue：队列内的元素必须实现Delayed接口，这就意味这传进去的任务必须先实现Delayed接口。当这个队列接收到任务时，首先会入队，达到指定延时时间之后，才会执行任务。

### 拒绝策略

当线程池中的缓存队列已满，而且线程数达到maximumPoolSize，如果还有新的任务到来，就会执行拒绝策略

简单来说， **线程数>最大线程数+缓存队列时，会触发拒绝策略** 

- ThreadPoolExecutor.AbortPolicy：丢弃新到来的任务，并抛出RejectedExecutionException
- ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常
- ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
- ThreadPoolExecutor.CallerRunsPolicy：使用调用者线程(提交任务的线程)来处理任务。可能会降低新任务的提交速度，影响整体性能。这个策略还喜欢增加队列容量。

### 线程池关闭

- shutdown()：不会立即终止线程池，而是要等到缓存队列中的任务都执行完之后才终止，但是不会接收新任务
- shutdownNow()：立即终止线程池，尝试打断正在执行的任务，清空任务缓存队列，返回尚未执行的任务

### Java提供的线程池

| 方法                 | corePoolSize | maximumPoolSize   | keepAliveTime | workQueue           |
| -------------------- | ------------ | ----------------- | ------------- | ------------------- |
| CachedThreadPool     | 0            | Integer.MAX_VALUE | 60s           | SynchronousQueue    |
| FixedThreadPool      | nThreads     | nThreads          | 0             | LinkedBlockingQueue |
| SingleThreadExecutor | 1            | 1                 | 0             | LinkedBlockingQueue |
| ScheduledThreadPool  | corePoolSize | Intger.MAX_VALUE  | 0             | DelayQueue          |

### 如何配置线程池大小

- CPU密集型：使用较小的线程池，一般为 核心数+1
- IO密集型：一般为 2*核心数
- 混合型任务：将任务分为IO密集型和CPU密集型，交给不同的线程池去处理。只要分别执行的时间数量级相差不大，就会比串行执行更高效。

## ThreadLocal

ThreadLocal提供了线程内存储变量的能力,  每一个线程读取的变量是对应且相互独立的.

- 对于某一个 `ThreadLocal` 来讲,他的索引值 `i` 是确定的, 在不同的线程间访问时,  访问的是不同 `table` 数组的同一位置, 即都是 `table[i]` , 只不过不同线程之间的 `table` 是互相独立的
- 对同一线程的不同 `ThreadLocal` 来讲, 这些 `ThreadLocal` 共享一个实例 `table` 数组,  然后每个 `ThreadLocal` 实例在 `table` 中的索引 `i` 是不同的



`ThreadLocal` 的静态内部类 `ThreadLocalMap` 为每个 `Thread` 都维护了一个数组 `table` ,  `ThreadLocal` 确定了一个数组下标,  而这个下标就是 `value` 存储的对应的位置.

### 如何定位到threadlocal的位置

在ThreadLocalMap中的set方法与构造方法都能看到以下字段

```
int i = key.threadLocalHashCode & (len-1)
int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY-1)
```

通过计算索引值，从数组中对应位置取值

索引值如何计算的：在 `new ThreadLocal()` 时，因为 `threadLocalHashCode` 的初始化，会使 `threadLocalHashCode` 值自增一次，增量为 `0x61c88647` 

这个增量是斐波那契散列乘数，优点是通过它hash出来的结果会比较均匀，可以最大限度的减少散列冲突

### ThreadLocal.set()方法

```
//set 方法
public void set(T value) {
      //获取当前线程
      Thread t = Thread.currentThread();
      //获得此线程的ThreadLocalMap (实际存储的数据结构类型,每个线程都有一个)
      ThreadLocalMap map = getMap(t);
      //如果存在map就直接set，没有则创建map并set
      if (map != null)
          map.set(this, value);
      else
          createMap(t, value);
  }
  
//getMap方法
ThreadLocalMap getMap(Thread t) {
      //thred中维护了一个ThreadLocalMap, threadLocals是线程内的一个变量
      return t.threadLocals;
 }
 
//createMap
void createMap(Thread t, T firstValue) {
      //实例化一个新的ThreadLocalMap，并赋值给线程的成员变量threadLocals
      //实例化ThreadLocalMap,就是要创建一个Entry数组
      t.threadLocals = new ThreadLocalMap(this, firstValue);
}
```

`ThreadLocalMap.set()` 方法

- 获取索引值
- 遍历tab,  如果存在就更新值
- 如果没有遍历成功,  就创建值

### ThreadLocalMap

```
//Entry为ThreadLocalMap静态内部类，对ThreadLocal的弱引用(这里可能导致内存泄漏)
//同时让ThreadLocal和储值形成key-value的关系
static class Entry extends WeakReference<ThreadLocal<?>> {
    /** The value associated with this ThreadLocal. */
    Object value;
    Entry(ThreadLocal<?> k, Object v) {
           super(k);
            value = v;
    }
}

//ThreadLocalMap构造方法
ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
        //内部成员数组，INITIAL_CAPACITY值为16的常量
        table = new Entry[INITIAL_CAPACITY];
        //位运算，结果与取模相同，计算出需要存放的位置(在table数组中存放的位置)
        //threadLocalHashCode比较有趣
        int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);
        table[i] = new Entry(firstKey, firstValue);
        size = 1;
        setThreshold(INITIAL_CAPACITY);
}
```

### ThreadLocal.get()

```
//ThreadLocal中get方法
public T get() {
    //得到当前的线程
    Thread t = Thread.currentThread();
    //得到 ThreadLocalMap
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
    
//ThreadLocalMap中getEntry方法
//通过计算索引得到数组中的下标
private Entry getEntry(ThreadLocal<?> key) {
       int i = key.threadLocalHashCode & (table.length - 1);
       Entry e = table[i];
       if (e != null && e.get() == key)
            return e;
       else
            return getEntryAfterMiss(key, i, e);
}
```

### 内存泄漏

原因:

- `ThreadLoacl` 中的 `key` 是 `Thread Local` 的弱引用,  而 `value` 是强引用.
- 如果 `ThreadLocal` 如果没有被外部强引用,  在垃圾回收时, `key` 会被清理掉, 而 `value` 不会被清理
- 这样就会出现 `key` 为空,的 `Entry` , `value` 永远无法被回收, 就可能产生内存泄漏

措施:

- `ThreadLocal` 在调用 `set() get() remove()` 方法时,  会清理掉 `key` 为空的记录
- 使用完 `ThreadLocal` 后,  最好手动调用 `remove()` 方法

## Atomic原子类

## 线程、进程、线程池的状态

### 进程的几种状态

- 创建：为一个新进程创建PCB（进程控制块，它是系统为了管理进程设置的一个专门的数据结构，主要表示进程的状态），把该进程转入到就绪状态并插入到就绪队列之中
- 就绪：当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，这种状态是就绪状态
- 执行：进程已获得CPU，其程序正在执行
- 阻塞：正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃CPU而处于暂停状态，亦即进程的执行受到阻塞，把这种暂停状态称为阻塞状态
- 终止：等待操作系统进行善后处理，然后将其PCB清零，并将PCB空间返还系统

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1102741/1593476505274-59341dad-449a-47fe-82d7-9dea77e28a52.png)

有些还会具有挂起状态，具有挂起状态的转换图如下：

引起挂起的原因有：

-  终端用户的请求：当终端用户在自己的程序运行期间发现有可疑问题时，希望暂时使自己的程序静止下来。
- 父进程请求：有时父进程希望挂起自己的某个子进程，以便考查和修改该子进程，或者协调各子进程间的活动。
- 负荷调节的需要。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行。
- 操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1102741/1593479321180-349f2ef1-5140-4c59-9994-502dc21920c1.png)

### 线程的几种状态

- 初始：
- 运行：
- 等待：
- 阻塞：
- 终止：

![img](https://cdn.nlark.com/yuque/0/2020/jpeg/1102741/1593479483073-7197f320-80ac-418a-a108-d741893245a7.jpeg)

### 线程池的几种状态

- RUNNING：创建线程池，初始时，处在此状态
- SHUTDOWN：调用shutdown()方法，处于此状态，此时不接收新任务，但是会等待所有任务执行完毕
- STOP：调用shutdownNow()方法，处于此状态，此时不接收新任务，并且尝试终止正在执行的任务
- TIDYING：处于SHUTDOWN或STOP状态，并且所有工作线程都销毁，任务缓存队列清空或执行结束后，线程池会处在此状态
- TERMINATED：在执行 `terminated()` 方法之后会进入到此状态

# JavaWeb

## SpringBoot

### AOP

#### 动态代理实现AOP

```
//代理类都必须继承 InvocationHandler 接口
public class WorkHandler implements InvocationHandler {
    //要代理的真实对象
    private Object obj;

    public WorkHandler(Object obj) {
        this.obj = obj;
    }

    /*proxy：传入的代理实现类，在这里代理类和真实对象产生联系
    **method：调用对象真实的方法的method对象
    **args[]：代理对象方法传递的参数
    **/
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //再真实对象执行之间添加自己的操作
        System.out.println("before invoke");
        //实现被代理对象原有的方法
        Object invoke = method.invoke(obj, args);
        System.out.println("after invoke");
        return invoke;
    }
}


public class test {
    public static void main(String[] args){
        //要代理的真实对象
        People people = new Teacher();

        //代理对象的调用程序，我们要把真实的对象传入代理对象的调用程序中的 构造函数中
        //最终代理对象的调用程序会调用真实对象的方法
        InvocationHandler handler = new WorkHandler(people);

        //通过 Proxy类的 newProxyInstance 的方法来创建代理对象
        //第一个参数：定义由哪个类加载器对生成的代理类进行加载
        //第二个参数：给代理类对象提供一组什么样的接口
        //第三个参数：当动态代理对象调用方法时，会关联到哪一个代理对象上

        //newProxyInstance产生的实例可以被强转成 people，说明在这个方法里，我们的代理类应该继承或实现了专门创建的接口，这样才把两个类连接起来
        //在需要 继承proxy类获取有关方法 和 InvocationHandler构造方法传参  时，java不能同时继承两个类，想要和代理类建立联系，只能实现接口
        People proxy = (People) Proxy.newProxyInstance(handler.getClass().getClassLoader(), people.getClass().getInterfaces(), handler);

        System.out.println(proxy.work());
    }
}
```

#### 动态代理

- jdk：被代理的类必须是实现某个接口
- cglib：可以直接对实现类进行操作而非接口

### SpringMvc中的注释

```java
@Controller
@RequestMapping("/brand")
public class PmsBrandController{
    @Autowired
    private PmsBrandService demoService;

    @RequestMapping(value = "listAll", method = RequestMethod.GET)
    @ResponseBody
    public CommonResult<List<PmsBrand>> getBrandList() {
        List<PmsBrand> pmsBrands = demoService.listAllBrand();
        System.out.println(demoService.listAllBrand());
        return CommonResult.success(demoService.listAllBrand());
    }

    @RequestMapping(value = "/update/{id}", method = RequestMethod.POST)
    @ResponseBody
    public CommonResult updateBrand(@PathVariable("id") Long id, @RequestBody PmsBrand pmsBrandDto, BindingResult result) {
        CommonResult commonResult;
        System.out.println(demoService.getBrand(id));
        int count = demoService.updateBrand(id, pmsBrandDto);
        if (count == 1) {
            commonResult = CommonResult.success(pmsBrandDto);
            LOGGER.debug("updateBrand success:{}", pmsBrandDto);
        } else {
            commonResult = CommonResult.failed("操作失败");
            LOGGER.debug("updateBrand failed:{}", pmsBrandDto);
        }
        return commonResult;
    }
}
```

* `@RequestMapping`
  * 作用：处理请求地址的映射
  * 范围：类上可以有，方法上必须有（通过此映射路径来寻找方法）
  * `getBrandList()`的路径是`/brand/listAll`：类路径+方法路径
* `@RequestBody`
  * 范围：作用在方法上
  * 作用：将方法的返回结果写入Http响应正文（ResponseBody）中，一般在获取数据时使用
    * 如果不使用此注解，在使用`@RequestMapping`后，返回值会解析为`跳转路径`
    * 如果使用此注解，不会被解析为跳转路径，会直接写入Http响应正文
  * `getBrandList()`方法会返回json数据
* `@RequestBody`
  * 用于读取Request请求的body部分，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上
  * 再把HttpMessageConverter返回的对象数据绑定到controller中的方法参数上
  * `updateBrand()`方法中，使用`@RequestBody`把`PmsBrand`对象写入`pmsBrandDto`中

#### 获取请求路径中的参数

`http://localhost:8080/springmvc/hello/101?param1=10&param2=20`

```java
@RequestMapping("/hello/{id}")
    public String getDetails(@PathVariable(value="id") String id,
    @RequestParam(value="param1", required=true) String param1,
    @RequestParam(value="param2", required=false) String param2){
.......
}
```

`@PathVariable`

* 作用：获取请求路径中的动态参数
* `getDetails`方法中，使用`@PathVariable("id") String id`来获取`/hello/{id}`中的`id`变量

`@RequestParam`

* 作用：获取请求路径中的参数
* 使用类似于 key-value 的方式来获取参数

**@RequestParam参数加与不加的区别**

* 加了此注解，就必须有参数（required=false 之后可以不带参数）
* 不加此注解，有没有参数都可以（这么看来，这个注解没啥用）

`@PathParam`

- 这个注解是和spring的`pathVariable`是一样的，也是基于模板的，但是这个是jboss包下面的一个实现，上面的是spring的一个实现，都要导包

`@QueryParam` 

- @QueryParam 是 JAX-RS 本来就提供的，和Spring的`RequestParam`作用一致

## SpingCloud

## Session

### 服务器重启session会失效吗

- 如果服务器不支持持久化，在服务器关闭时，会触发 `session destory` 事件
- 如果服务器支持持久化，在服务器关闭时，不会触发销毁事件，而是把每个Session内容写入文件中。当服务器再次启动时，会读取该文件，验证session是否timeout。

# 中间件

## 消息队列

消息队列可以看作是存放消息的容器，当我们需要消息的时候，可以取出消息供自己使用。

消息队列是分布式系统中的重要组件，使用消息队列是为了通过异步处理来提高系统的性能和削峰、降低系统耦合性。

### 为什么使用消息队列

- 解耦

  - 消息队列使用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接收者（消费者）订阅消息。消息发送者和消息接收者之间没有直接耦合。
  - 为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等到消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。

- 通过异步处理提高系统性能（减少响应所需时间）

  - A接收到的请求，需要在本地写库，也需要在BCD三个系统写库。如果不进行异步处理，一个操作的响应时间就是A+B+C+D，响应会十分缓慢。如果进行了异步操作，A只需要在本地写库之后把数据发到消息队列即可，耗时 A写库+A写消息队列

- 削峰

  - 在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下，数据库压力剧增，会使响应速度变慢。在使用消息队列之后，用户的请求数据写入消息队列之后立即返回，再由消息队列的消费者进程从消息队列中获取数据，异步的写入数据库。由于消息队列服务器的处理速度快于数据库，所以响应速度会得到大幅度的改善。
  - 通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，来削平高峰期的并发事务。

### 消息队列带来的一些问题

- 系统可用性降低
- 系统复杂性提高：消息重复消费、消息丢失
- 一致性问题

### 各种消息队列的比较

- ActiveMQ：性能较差，版本迭代很慢。主从架构
- RabbitMQ：吞吐量低于Kafka和RocketMQ，但是它基于erlang开发，所以并发能力很强，性能极其好，延时很低，能达到微秒级。如果业务场景对并发量的要求不是太高（十万级、百万级），RabbitMQ是首选。主从架构
- RocketMQ：阿里出品，Java系开源项目。分布式架构
- kafka：提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，并且分布式可以任意扩展。kafka的劣势就是可能造成消息的重复消费，对数据的准确性会造成轻微的影响。

### 路由交换机的几种类型

`Exchange` ：消息交换机，它指定消息按照什么规则，路由到哪个队列

- Direct Exchange：直接匹配，通过Exchange名称+RoutingKey来发送与接受消息
- Fanout Exchange：广播订阅，向所有的消息者发布消息，但是只有消费者将队列绑定到该路由器才能收到消息，忽略RoutingKey
- Topic Exchange：主题匹配订阅,这里的主题指的是RoutingKey,RoutingKey可以采用通配符,如:*或#，RoutingKey命名采用.来分隔多个词,只有消息这将队列绑定到该路由器且指定RoutingKey符合匹配规则时才能收到消息
- Headers Exchange：消息头订阅,消息发布前,为消息定义一个或多个键值对的消息头,然后消费者接收消息同时需要定义类似的键值对请求头:(如:x-mactch=all或者x_match=any)，只有请求头与消息头匹配,才能接收消息,忽略RoutingKey

## 消息队列常见问题

### 如何保证高可用

RabbitMQ有三种模式：单机模式、普通集群模式、镜像集群模式

镜像集群才是真正的高可用

#### 普通集群模式

在多台机器上启动多个rabbitmq实例，但是你创建的queue，只会存放到一个rabbitmq实例上，其他的实例都只是同步queue的元数据。当进行消费的时候，如果消费者连接到的是另外一个实例，那么这个实例会从queue所在的实例拉取数据过来。

- 如果消费者每次随机连接一个实例，就会有数据拉取的开销
- 如果消费者每次固定连接queue所在的实例，那么就会有单实例性能瓶颈

如果存放queue的实例宕机了，那么就无法拉取消息了。

如果开启了消息持久化，也要等到节点恢复了才能继续读取消息。

**普通集群不是保证高可用的，只是为了增加吞吐量** 

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1102741/1594794619593-9084a960-61ff-4cde-96b3-a9116165345b.png)

#### 镜像集群

和普通集群的区别是，创建的queue无论是元数据还是queue里卖弄的消息，都会存储在多个实例上。

每次写消息到queue时，都会自动把消息和多个实例上的queue进行消息同步

好处：某个实例宕机了，别的机器还可以用，服务还可以继续

坏处：性能开销太大，同步所有机器会造成网络压力变大；扩展性差，没有办法线性性扩展，因为每台机器都要包含queue的所有消息

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1102741/1594795154932-815cdc6b-98ef-40e6-a5fd-4efaec09eaac.png)

#### kafka高可用性

kafka的基本架构：

- kafka由多个broker组成，每个broker都是一个节点
- 创建一个topic，这个topic可以划分为多个partition
- 每个partition可以存放在不同的broker上，每个partition就存放一部分数据

kafka高可用性：每个节点都有副本，leader挂掉之后，副本可以竞争成为leader。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1102741/1594795635545-bb63b7f8-5fbb-49cf-a40e-e2f839436cc2.png)

### 如何保证不被重复消费

为什么会有重复消费？

以kafka为例，每个消息写进去都会有 `offset` ，代表它的序号，然后消费者消费之后，每隔一段时间都要把自己消费过的offset交代一下，代表我已经消费过这个信息了，下次重启的时候，从上次消费过的开始。

如果系统重启的时候， `offset`还没有提交，那么下次消费的时候，就会有些消息会被重复消费。

**幂等性**：一个数据或者一个请求重复多次，要保证对应的数据是不会出错的

如何保证不被重复消费（结合业务场景）？

- 如果数据要写库，现根据主键查一下，要是数据已经有了，就别插入了，update一下
- 如果是写redis，redis的set具有天然幂等性
- 让生产者发送数据的时候，里面加一个全局的唯一id，类似订单id，然后消费到了之后，先根据这个id去（比如redis里）查一下消息是否被消费过。如果没有被消费过，就对消息进行处理，然后写redis；如果消费过，就不用做任何处理。

### 如何保证可靠性传输

#### rabbitmq

- 生产者弄丢了数据（发送数据到rabbitmq时，信息丢失）

  - 可以采用rabbitmq的事务功能，生产者发送数据之前开启rabbitmq的事务，然后发送消息。

    - 如果消息没有成功被rabbitmq接收到，那么生产者就会产生异常报错，回滚事务。
    - 如果收到消息，就提交事务。
    - 缺点：吞吐量会下降，因为太耗费性能

  - 在生产者设置那里开启 `confirm` 模式

    - 每次写的消息都会分配一个唯一的id，然后写入rabbit中，rabbit会回传一个ack消息，告诉接收成功
    - 如果没能处理这个消息，就会回调一个 nack 接口，搞素消息接受失败，可以重试。
    - 可以结合这个机制，自己在内存里维护每个消息的id状态，如果超过一定时间还没收到回调，就重试

  - 两者的不同之处在于，事务机制是同步的，提交事务的时候会阻塞；confirm 机制是异步的，发送之后可以继续发送别的消息，rabbitmq接收之后会异步回调一个接口通知你消息收到了

- rabbitmq弄丢了数据

  - 开启rabbitmq的持久化，消息写入之后持久化到磁盘。即使rabbitmq自己挂掉，恢复之后也会自动读取之前存储的数据，一般不会丢失。（除非在rabbitmq持久化之前挂掉，可能导致少量数据丢失）
  - 设置持久化的步骤

    - 创建queue的时候将其设置为持久化，这样可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里的数据
    - 发送消息的时候将消息的 `deliveryMode` 设置为2，这就是将消息设置为持久化的

  - 持久化可以和生产者的 `confirm` 机制结合起来，只有在持久化到磁盘之后，才通知生产者ack。这样rabbitmq在持久化到磁盘之前挂掉，也会重发数据。

- 消费端丢失数据（刚消费到，还未处理，进程挂掉）

  - 使用rabbitmq提供的ack机制，关闭rabbitmq的自动ack，可以通过一个api来调用，在自己的代码确保处理完之后，再进行ack。这样的话，没有处理的消息就会分给其他的消费者，不会丢失。

#### kafka

- 消费端弄丢数据（消费者再处理之前旧提交了offset，然后挂掉）

  - 关闭自动提交offset，再处理完之后手动提交offset。这样可能会导致重复消费，需要自己保证幂等性

- kafka弄丢数据（其他follower再同步数据的时候，leader挂掉）

  - 给topic设置 `replication.factor` 参数：这个值必须大于1，要求每个partition至少拥有两个副本
  - kafka服务端设置 `min.insync.replicas` 参数：这个值必须大于1，要求一个leader要感知到至少还有一个follower跟自己保持联系
  - producer端设置acks=all：要求每条数据必须写入所有replica之后，才能被认为写入成功
  - producer端设置retires=MAX（很大很大的值，无限重试）：要求一旦写入失败，就无限重试

- 生产者端在上述设置（acks=all）之后，不会丢失数据

### 如何保证消息顺序

#### rabbitmq保证消息的顺序性

- 拆分多个queue，每个queue对应一个customer
- 一个queue但是对应一个customer，然后在这个customer内部用内存队列做排队，然后分发给底层不同的worker来处理

#### kafka保证消息的顺序性

kafka写入partion时指定一个key，例如订单id，那么消费者从partion中取出数据时肯定是有序的。

当开启多个线程的时候可能导致数据不一致，这时可以使用内存队列，将相同的hash过的数据放到一个内存队列中，这样就能保证一条线程对应一个内存队列的数据，在写入数据库的时候是有序的，从而可以开启多条线程对应多个内存队列。

# JVM

## Java内存区域（运行时数据区）

### 程序计数器

线程私有，可以看作当前线程所执行的字节码的行号指示器

**作用** 

- 字节码解释器通过改变计数器的值来一次读取指令，从而实现代码的流程控制。（如顺序、选择、循环等）
- 在多线程的情况下，程序计数器用来记录当前线程执行的位置，从而当线程被切换回来的时候，就能知道该线程上次运行到哪里了

### 虚拟机栈

- 线程私有，生命周期和线程相同，描述的是Java方法执行的内存模型
- 方法的运行，对应着栈帧的入栈与出栈
- 虚拟机栈由栈帧组成，每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出入口信息
- 局部变量表存放的是：编译器可知的 各种数据类型、对象引用

**异常** 

- StackOverFlowError：Java虚拟机栈的内存不允许动态扩展，且线程请求的栈深度达到虚拟机栈的最大深度
- OutOfMemoryError：虚拟机栈的内存允许扩展，但是线程请求栈时内存用完了，无法再动态扩展

### 本地方法栈

- 线程私有
- 虚拟机使用到的 Native 方法服务
- 栈帧和异常都和上一个类似

### 堆

- 线程共享
- 存放对象实例，几乎所有的对象实例和数组都在堆上分配

### 方法区

- 线程共享
- 存储已经被虚拟机加载的 类信息、常量、静态变量、即时编译器编译后的代码数据

### 运行时常量池

- 是方法区的一部分
- 用于存放 各种字面量和符号引用
- JDK1.7之后，运行时常量池从方法区中移动到了堆中

​         ![image.png](https://cdn.nlark.com/yuque/0/2020/png/1102741/1592707241466-e971aa9b-5286-4806-91b2-354ebf851512.png)

### 方法区和永久代的关系

- Java虚拟机规范中，规定了方法区有这么个概念和它的作用，但是没有规定如何去实现它
- 方法区和永久代的关系像是Java中接口和类的关系，类实现的接口
- 永久代就是 HotSpot 虚拟机对方法区的是实现方式

### 为什么将永久代替换为元空间

- 永久代有一个JVM设置的固定大小上限，无法进行调整
- 元空间使用的是直接内存，受本机可用内存限制，不会得到 OutOfMemoryError
- 一些其他的原因

### 对象创建的过程

- 类加载检查：虚拟机遇到一条 new 指令时，首先检查这个指令的参数能否在常量池中定位到这个类的符号引用。并且检查这个符号引用代表的类是否已经被加载、解析和初始化过。如果没有，就先执行相应类的加载过程。
- 分配内存：在类加载之后，就开始为对象分配内存，对象所需内存大小，在类加载完之后便可以确定。分配内存的方式有“指针碰撞”和“空闲列表”两种。选择那种方式由Java堆是否规整来决定，而Java堆是否规整又由垃圾收集器是否带有压缩整理功能来决定。
- 初始化零值：将分配到的内存空间初始化零值，保证了对象的实例字段在Java代码可以不赋初值就直接使用
- 设置对象头：虚拟机对对象进行必要的设置，这些信息都放在对象头中，主要包括：对象是哪个类的实例、如何让找到类的元数据信息、对象的Hash码、对象的GC分代年龄等。
- 执行 init 方法：上述步骤执行完之后，从虚拟机的角度看，一个新的对象已经产生。但是在Java程序的视角来看，init 方法还未执行，所有的字段都还是零值。执行 new 指令之后，需要接着执行 init 方法，把对象按着程序员的意愿进行初始化

## 类加载全过程

## 双亲委派模型

### 好处

- 保证了Java程序的稳定运行，可以避免类的重复加载。（JVM区分不同类的方式不仅仅是根据类名，相同的类文件被不同的类加载器加载，产生的也是两个不同的类）
- 保证了Java核心的API不会被更改

# 数据库

## MySQL

### 基本架构（查询语句的如何执行）

Server层：

- 连接器：在登陆MySQL的时候，进行身份认证和权限登录。如果账号密码都通过，就回去权限表中查询该用户的所有权限。
- 查询缓存：在执行查询语句的时候，会先查询缓存（MySQL8.0版本之后移除，因为不太实用）。MySQL会先校验这个sql是否被执行过，以Key-Value的形式缓存在内存中，key是查询预计，value是结果集。如果key被命中，就直接返回结果；如果未命中，就会执行后续的操作，完成后把缓存结果存起来。
- 分析器：如果缓存未命中，SQL语句就会经过分析器。分析器主要分为两步，词法分析：提取关键词，比如表明、字段名、查询条件等；语法分析：判断输入的sql是否正确，是否符合MySQL的语法。
- 优化器：按照MySQL认为最优的方案去执行，比如多个索引的时候如何去选择索引，多表查询的时候如何选择关联顺序等。
- 执行器：执行语句，然后从存储引擎返回数据。首先在执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息；如果有权限，就会调用执行引擎的接口，返回执行结果。

引擎层：

- 主要负责数据的存储和读取，采用可替换的插件式架构，支持InnoDB、MyISAM等多个存储引擎
- MySQL5.5版本之后，InnoDB引擎就作为默认存储引擎

### 索引

#### 索引创建

- 创建单列索引

  - 普通索引：最基本的索引 `CREATE INDEX indexName ON `tableName`(`字段名`)` 
  - 唯一索引：与普通索引的不同之处是，要求索引列中类的值是唯一的，但是允许有空值

```
CREATE UNIQUE INDEX uniqueIndexName ON `tableName`(`字段名`)
```

- 主键索引：不允许有空值（在B+tree中InnoDB引擎中，主键索引起了至关重要的作用）

- 创建组合索引

组合索引：包含多个字段，但是只有一个索引名称，使用查询时要遵循 **组合索引的最左前缀规则** 

```
CREATE INDEX nicknameIndex ON `tabkeName`(`字段名`,`字段名`)
```

#### 组合索引的最左前缀规则

- 不按索引的最左列开始查询，就不能使用索引

例如： `index(`c1`, `c2`, `c3`)  WHERE  `c2`=`aaa`` ，就不能使用索引

- 查询中某个列有范围查询之后，则其右边的列都无法使用查询（多列查询）

`WHERE c1=`xxx`` 和 `WHERE c1 like `xx%`` 会使用到索引

而 `WHERE c1=`%xx`` 就不会使用到索引

- 使用范围查询就会停止匹配，索引查询最多只适用于一个范围列
- 查询条件中包含函数或者表达式，也会导致索引失效而进行全表扫描

#### 索引的优点

- 在查询中使用索引，可以提高性能（使用78w条地理位置数据，不使用索引 0.174s，使用索引 0.001s）
- 通过建立唯一索引或者主键索引，可以保证数据库表中每一行数据的唯一性
- 建立索引可以大大提高检索的数据，减少表的检索行数
- 在表连接的连接条件，可以加速表与表直接的相连

#### 使用索引的缺点

- 创建和维护索引会耗费时间，随着数据量的增加而增加
- 索引会占用物理空间，除了数据表占用的空间外，每个索引还会占用一定的物理空间
- 当对表的数据进行插入，更新，删除的时候，索引也要动态地维护，会降低数据维护的速度

#### 什么情况下不应该创建索引

- 当表的修改，更新，删除操作远远大于查询操作的时候，不应该创建索引
- 查询中很少使用到的字段不应建立索引
- 很少数据的列（比如性别），也不应建立索引算法



### 连接查询（JOIN）

```
SELECT  xx  FROM  xx  LEFT(RIGHT/INNER) JOIN  xx  on xx.x=xx.x
```

- 左连接：左表全部展出，右表展出符合条件的
- 右连接：右表全部展出，左表展出符合条件的
- 内连接：返回两个表都有的部分
- 全连接：MySQL不能使用全连接，但是可以使用 `左连接 union 右连接` 来实现全连接

### 为什么不能使用 select *

* 在业务方面：`select *` 会引入很多多余的字段（字段多余）
* 在数据库性能方面：
  * 缓存：`select *` 查出来的数据多，会白白占用比较多的缓存空间
  * 覆盖索引：如果仅仅检索需要的数据，可能会符合 覆盖索引 ，这样就不需要回表，减少一次检索耗时

## 一致性哈希算法

参考链接：[一致性hash](https://www.jianshu.com/p/e968c081f563)

### 使用hash的问题

hash算法通过取模运算（对服务器的数量取模），来进行缓存查找，必然会出现一下几个问题

- 增加一台服务器的时候，所有缓存的位置都会改变
- 减少一台服务器的时候，所有的缓存位置都会改变

这个问题会造成缓存雪崩（由于原有的缓存失效，新缓存未到期间，原本应该访问缓存的请求都去查询数据库，对数据库CPU和内存造成了巨大压力，严重的会造成数据库宕机，引发一系列反应，造成系统崩溃）

### 一致性hash算法

一致性hash也是采用的取模运算来找到数据的位置，只不过一致性hash算法不是对服务器的数量取模，而是对2^32-1取模。

- 一致性hash算法将整个hash空间组成一个虚拟的圆环，0 ~ 2^32-1，整个空间按顺时针方向组织。
- 将服务器的主机名或者ip地址做为关键字进行hash，计算出每个服务器的位置。
- 接着对数据的key值使用相同的函数hash计算出哈希值，确定此数据在圆环上的位置。
- 从此位置顺时针行走，遇到的第一个服务器就是此数据定位到的服务器。

### 一致性hash算法的特点

- 单调性：已经有一些请求通过哈希分配到了相应的服务器进行处理，此时有又有新的服务器加入到系统中，应该保证原有的请求可以被映射到原有的或者新的服务器中去，而不是映射到原来的其它服务器上去。
- 分散性：一致性hash拥有很低的分散性。分散性是指，在分布式环境中，客户端请求时可能不知道所有服务器的存在，只知道一部分服务器的存在，如果多个客户端都把部分服务器作为完整的hash环，可能导致相同的请求被映射到不同的服务器。分散性是指以上情况发生的严重程度。
- 平衡性：每台服务器处理请求的数量大致相同（通过虚拟节点来实现）



为什么可以降低分散性：因为采用一致性hash算法，请求数据的key值映射的位置都是确定的，只要几台服务器都知道存储该数据的服务器，就可以找到该数据，对能否知道其他服务器没要求。如果采用一般的hash算法，hash运算会严重受到服务器数量的影响。

### 如何解决数据倾斜问题

一致性hash算法通过增加虚拟节点来实现，即对每一个服务器节点计算多个hash，在每个计算结果位置都放置一个此服务节点，具体做法可以在服务器后面加编号来实现，再多一步虚拟节点到实际节点的映射就可以。在实际应用中，将虚拟节点设置为32甚至更大，因此很少的节点也可以做到数据均衡分布。

## 布隆过滤器

BloomFilter相当于一个不太精确的Set集合，通过其Contains方法来判断某个元素是否存在。

- 如果判断一个元素不存在，那么这个元素一定不存在
- 如果判断一个元素存在，那么这个元素不一定存在

BloomFilter在Redis中，对应着一个大型的位数组和几个不同的hash函数

添加操作：

- 根据hash函数，来对元素进行hash计算得索引值
- 然后用索引值对数组长度取模，得到位置
- 几个不同的hash函数将得到几个不同的位置，将数组中的对应位置设置为1

检查元素是否存在

- 根据hash函数计算元素的索引值
- 索引值对数组长度取模，得到位置
- 检查几个位置是否全部为1。如果全部都是1，说明元素可能存在；如果不全为1，说明元素一定不存在