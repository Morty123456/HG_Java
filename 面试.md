# Java

## Java基础

### 作用域与可见性

| 作用域与可见性 | 当前类 | 同一package | 子类 | 其他package |
| -------------- | ------ | ----------- | ---- | ----------- |
| public         | √      | √           | √    | √           |
| protected      | √      | √           | √    |             |
| default        | √      | √           |      |             |
| private        | √      |             |      |             |

### 重载和重写

|            | 重载     | 重写                                 |
| ---------- | -------- | ------------------------------------ |
| 发生范围   | 同一个类 | 子类中                               |
| 参数列表   | 必须修改 | 一定不能修改                         |
| 返回类型   | 可修改   | 一定不能修改                         |
| 异常       | 可修改   | 可以减少或删除,不能抛出更多的异常    |
| 访问修饰符 | 可修改   | 可以降低修饰级别, 不能做更严格的限制 |
| 发生阶段   | 编译期   | 运行期                               |

### 面向对象的特性

- 封装
- 继承：子类拥有父类对象所有的属性和方法（但是无法访问父类的私有属性和方法）。因为在一个子类被创建时，首先会在内存中创建一个父类对象，然后在父类对象外部放上子类独有的属性，两者结合起来形成一个子类对象。
- 多态：程序中定义的引用变量所指向的具体类型和通过该引用变量的方法调用,在编程的时候是不确定的,只有运行期间才是确定的。

编译期多态:  比如重载

运行期多态:  比如重写

### Java中无参构造方法的作用

- Java在执行子类的构造方法之前, 如果没有采用 `super` 调用父类特定的构造方法, 就会调用父类中的 "无参构造方法"
- 如果父类中只定义了有参的构造方法, 而在子类中又没有使用 `super` 来调用父类中指定的构造方法, 则在编译时会发生错误, 因为找不到父类的无参构造方法
- 所以需要在父类中加上一个无参构造方法

### new String("abc")

- JVM检查字符串常量池中是否存在 "abc" 字符串
- 如果不存在，则现在字符串常量池中创建 "abc"
- 在堆内存中创建一份字符串对象，拷贝字符串常量池中的 "abc" 到内存中的字符串对象中
- 返回堆内存中该字符串的内存地址

```
String str1 = "abc";
String str2 = "abc";
String str3 = new String("abc");
String str4 = new String("abc");
```

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1102741/1593915022822-8920a1cd-129f-4d04-b5d7-a0b231d04602.png)

### 自动拆装箱

实现原理：是程序在编译的时候，编译器帮助我们完成这项任务的

* 自动装箱是通过包装类的 valueOf(*) 方法实现的  `Integer integer = Integer.valueOf(1)`
* 自动拆箱是通过包装类了 ***Value() 来实现的 `int i = Integer.intValue()`

### byte、位

b 位 bit

B 字节 byte 

1byte = 8bit

1MB = 1024KB = 1024*1024B

### String 为什么不可变

* string 里面的 char 数组是 final 修饰的，指向的对象不能变
* string 内部的 char 数组是 private，而且没有提供 public 的接口去修改 char 数组

## 关键字

### static

用法：

* 修饰成员变量和成员方法
  * static 修饰的变量 属于类，是静态变量；通过类名被调用；放在 Java 内存区域中的方法区
  * 如果被声明为 private，则只能在 类的内部被访问，而不能在类的外部被访问
* 静态代码块
  * 定义在 类中方法外
  * 执行顺序：静态代码块(只会执行一次) — 非静态代码块 — 构造方法
* 修饰内部类
  * 创建不需要依赖外围类
  * 不能使用任何外围类的非静态变量
* 静态导包

### final

用法

* 修饰变量
  * 修饰基本数据类型的变量时，必须赋予初始值并且不被改变
  * 修饰引用变量时，该引用变量不能再指向其他对象
* 修饰方法
  * 方法前加上final，代表这个方法，不能被子类重写
  * final 比 非final 方法快，因为在编译时已经静态绑定，不需要运行时动态绑定
* 修饰类
  * final 修饰的类 叫做 final类，final 类不能被继承

特性

* 被 final 修饰的对象内容是可变的（虽然对象不能被继承，但是内容依旧可以改变）

* final 与 static 对比
  * static 修饰变量时，会使该变量在类加载时就被初始化，不会因为对象的创建再次被加载，static修饰的变量只能被初始化一次

### default

* switch 中使用 default：当 case 里面与 switch 中的 key 不匹配时，执行 default 中的方法

* 在定义接口的时候，可以使用deafult修饰方法

  ```java
  public interface detest {
      default void showDefault(){
          System.out.println("default");
      }
      static void showStatic(){
          System.out.println("static");
      }
      void sayHi();
  }
  ```

  * 普通方法，必须被重写
  * default 修饰的方法：可以不用重写
  * static 修饰的方法：不能被继承的类访问，使用时直接调用接口

### super

作用在于：当子类中覆盖了父类的某个成员变量，或者重写了父类的某个成员方法时，还能够访问到父类的成员变量和成员方法

* super 调用父类构造方法，必须放在第一行执行

### this

this 是指向当前对象的引用

* this.属性名：指的是访问类中的成员变量，用来区分 成员变量和局部变量
* this.方法名：访问本类的成员方法
* this()：访问本类的构造方法
  * () 中可以有参数，如果有参数，就代表有参构造方法
  * this() 不能用于普通方法，只能写在构造方法中
  * 必须是构造方法中的第一条语句

* 在构造方法中的 this 关键字
  * 只能在构造方法中 通过 this 来调用其他构造方法，普通方法中不能使用
  * 不能通过 this 递归调用构造方法。不能在一个构造方法中，通过 this 直接或间接调用 该构造方法本身
  * 通过 this 调用其他构造方法，必须放在构造方法的第一行中执行
* 非构造方法中的 this 关键字：通过 this 调用类中的成员变量和方法

## IO模式

基本概念

* 同步：发起一个调用后，被调用者未处理完请求之前，不会返回
* 异步：发起一个调用请求，会立即得到被调用者的回应，表示已经接收到请求，但是被调用者并没有返回结果。此时我们可以处理其他请求，被调用者通常是依靠事件，回调等机制来通知调用者其返回结果
* 阻塞：阻塞就是发起一个请求，调用者一直等待请求结果返回，也就是当前线程会被挂起，无法从事其他任务，只有当条件就绪才能继续
* 非阻塞：非阻塞就是发起一个请求，调用者不用一直等着结果返回，可以先去干其他事情。

三种 I/O 模式

* BIO：同步阻塞IO

  数据的读取，必须阻塞在一个线程内等待其完成，适合于活动连接数不是特别多的情况

  但是无法处理十万级的连接

* NIO：同步非阻塞IO

  支持面向缓冲的，基于 通道的 I/O 操作方法

  核心组件

  * buffer (缓冲区)：I/O 面向流，NIO 面向缓冲区。在 NIO 中，所有数据都是使用缓冲区处理的
  * channel (通道)：NIO 的 所有 IO 都是从通道开始的
    * 从通道进行数据读取：创建缓冲区，然后请求通道读取数据
    * 从通道进行数据写入：创建缓冲区，填充数据，并要求通道写入数据
  * selectors (选择器)：NIO 有选择器，可以使用单个线程处理多个通道

  等待数据时不会被阻塞，程序可以做其他的事情。数据准备好了会提醒程序，程序再读取数据

* AIO：异步非阻塞IO

  异步I/O是基于事件和回调机制实现的，应用操作完成后会直接返回
  
  程序不用主动去读取数据，系统会为程序把数据读取好

## 异常

### error 和 exception

`Error` 和 `Exception` 类的父类都是 `Throwable` 类，主要区别如下：

- `Error` 类：主要与虚拟机相关的问题，如：系统崩溃，虚拟机错误，方法栈溢出。这将导致程序中断，依靠程序本身无法预防和恢复。
- `Exception` 类：分为运行时异常和受检查时异常

  - 运行时异常（非受检异常）：
    - 可以编译通过但是一运行就会停止，程序不会自己处理（空指针异常、数组越界等）
    - Java编译器 **不要求** 你一定要将其捕获 或者 一定要继续抛出
  - 受检查异常：
    - **要求必须要** 在方法里 捕获 或者 抛出 异常
    - 异常处理的方式（**应该尽量捕获和处理知道如何处理的异常，抛出不知如何处理的异常**）
      - 要么用 `try…catch…finally` 捕获，finally：无论发生异常都会执行，常用于清理资源
      - 要么用 `throws` 抛出，向外声明，交给父类处理

### throw 和 throws

- `throw` ：在方法体内部抛出异常，由方法体内部的语句处理；throw是具体向外抛出异常的动作，所以它抛出的是一个异常类。
- `throws` ：throws 在方法后声明，表示如果抛出异常，由方法的调用者处理。（有抛出异常的可能性，但是并不一定会抛出异常）

## 泛型

- Java泛型设计原则：只要编译期没有出现警告，那么在运行期就不会出现ClassCastException异常
- 定义：把类型明确的工作推迟到创建对象或调用方法的时候才会去确定的特殊类型
- 只作用于代码编译阶段，在编译过程中，对于正确检验泛型结果后，会将泛型的相关信息擦除，还是原来最基本的类型

```
//使用for遍历会出现问题，只知道是 object
List list = new ArrayList();
list.add("123");
list.add(123);
//使用泛型
List<String> list = new ArrayList();
list.add("123");
list.add(123);//这里会提示有错误
```

**泛型类型在逻辑上可以看成是多个不同的类型，实际上都是相同的基本类型** 

```
public class GenericTest{
    public static void main(String[] args){
        Box<String> name = new Box<String>("hg");
        Box<Integer> age = new Box<Integer>(10);
        System.out.println(name.getClass());    //com.Box
        System.out.println(name.getClass()==age.getClass());   //true
    }
}
class Box<T>{
    …………
}
```

在使用泛型类时，虽然传入了不同的泛型实参，但是并没有真正意义上生成不同的类型，传入不同泛型实参的泛型类在内存上只有一个，还是原来最基本的类型

## 反射

Java反射机制就是在运行状态中

- 对于任意一个类，都能知道这个类的所有属性和方法
- 对于任意一个对象，都能调用它的任意一个方法和属性

这种**动态获取的信息**以及 **动态调用对象的方法**的功能被称为java语言的反射机制

### 反射的原理与class对象

![img](https://cdn.nlark.com/yuque/0/2020/png/1102741/1594002038863-8f4aa082-b22a-4260-bbf5-bb438c5aa1a5.png)

`Class` 类的实例表示正在运行的 Java 应用程序中的类和接口。也就是jvm中有N多的实例每个类都有该Class对象。（包括基本数据类型）

### 反射的使用

使用的时候，记得捕捉异常

#### 获取Class对象

* 通过 **公有属性class** 获取 class 对象：通过类获取，无需创建类对象
* 通过 **方法getClass()** 获取 class 对象：需要类的对象。常用于不知道类名但是能获取对象的情况下
* 通过 **方法Class.forName()** 获取 class 对象：需要类的全名，会抛出异常。常用于加载配置

#### 通过反射获取对象实例

* Class.newInstance()：实际调用的是 无参构造函数 进行实例化
* Constructor.newInstance()：可以选择调用哪个函数进行实例化

**获取Class对象**

```
//第一种，已经得到对象了，就不必使用反射
Student stu1 = new Student();
Class stuClass = stu1.getClass();
System.out.println(stuClass.getName());
//需要导入依赖，依赖性太强
Class stuClass2 = Student.class;
System.out.println(stuClass2.getName());
System.out.println(stuClass2.equals(stuClass));
//最常用，带包名的路径
try {
    Class stuClass3 = Class.forName("JVM.Reflect.Student");
    System.out.println(stuClass3 == stuClass2);
}catch (ClassNotFoundException e){
    e.printStackTrace();
}
```

**获取构造方法** 

```
//加载class对象
Class clazz = Class.forName("JVM.Reflect.Student");
//所有"公有的"构造方法
Constructor[] conArray = clazz.getConstructors();
//获取所有的构造方法(包括私有、受保护、默认、公有)
Constructor[] conArray = clazz.getDeclaredConstructors();
//获取单个的"公有的"构造方法（参数类型）
Constructor con = clazz.getConstructor(null);
//获取"某个构造方法"可以是私有的，或受保护、默认、公有；
Constructor con = clazz.getDeclaredConstructor(char.class);

//这个方法可以新实例化一个对象，类型是Object
Object ob = con.newInstance();
//允许访问私有
con.setAccessible(true);
//但是如果在获取构造函数时，指定了参数，就可以获取Student对象
Constructor<Student> con = clazz.getDeclaredConstructor(char.class);
Student s = con.newInstance();
```

**获取成员变量** 

```
//获取Class对象
Class stuClass = Class.forName("JVM.Reflect.Student");

//获取所有公有字段
Field[] fields = stuClass.getFields();

//获取所有字段
Field[] fields = stuClass.getDeclaredFields();

//获取某个共有字段
Field f = stuClass.getField("name");
//调用构造方法创建新实例
Object object = stuClass.getConstructor().newInstance();
//设置字段值
f.set(object, "刘德华");
//新建student对象
Student student = (Student)object;
System.out.println(student.name);

//获取某个私有字段
Field f = stuClass.getDeclaredField("phoneNum");

//获取父类中的字段（以下的方法也是类似的）
//先获取父类，再获取字段（方法）
Field[] field = stuClass.getSuperclass().getDeclaredFields();
```

**获取成员方法** 

```
//获取class对象
Class stuClass = Class.forName("JVM.Reflect.Student");
//获取所有公有方法
Method[] methods = stuClass.getMethods();
//获取所有方法
Method[] methods = stuClass.getDeclaredMethods();

//获取某个公有方法（方法名，参数类型）
Method m = stuClass.getMethod("show1", String.class);
//新建实例对象
Object object = stuClass.getConstructor().newInstance();
//invoke就是调用method的方法，在这里就是调用m方法
m.invoke(object,"刘德华");

m.setAccessible(true);
//获取某个私有方法（方法名，参数类型）
Method m = stuClass.getDeclaredMethod("show4", int.class);
```

**越过泛型检查** 

这是因为泛型检查是在编译时期进行的，也就是说编译后的add()方法其实和没有指定泛型的add()方法是一致的，都是没有进行泛型检查的。所以通过反射获取ArrayList的Class文件对象中的add()方法,在调用该add()方法时是不用泛型检查的。

```
public static void fanxing() throws Exception{
    ArrayList<String> strList = new ArrayList<>();
    strList.add("aaa");
    strList.add("bbb");
    Class listClass = strList.getClass();
    Method method = listClass.getMethod("add", Object.class);
    method.invoke(strList, "100");
    for (Object obj : strList)
        System.out.println(obj);
}
```

## Java集合

- Collection

  - List

    - Vector：底层是数组，线程安全
    - ArrayList：
    - LinkedList：双向链表

  - Queue

    - LinkedList
    - PriorityQueue：基于堆结构实现，可以用来实现优先队列

  - Set

    - HashSet：无序
    - TreeSet：支持有序操作，查找效率不如HashSet
    - LinkedHashSet

- Map

  - HashMap：基于哈希表
  - TreeMap：基于红黑树

### HashMap

#### HashMap 为什么是不安全的

* 多线程情况下，A 线程的更改可能会 B线程覆盖

* JDK1.7 之前如果 A,B 都进行扩容操作，可能会造成死循环

  **JDK1.7 之前是头插法，JDK1.7之后是尾插法，所以不会有死循环发生了**

  因为头插法会产生循环
  
  ```java
  void transfer(Entry[] newTable, boolean rehash) {
      int newCapacity = newTable.length;
      for (Entry<K,V> e : table) {
          while(null != e) {
              //（关键代码）
              Entry<K,V> next = e.next;
              if (rehash) {
                  e.hash = null == e.key ? 0 : hash(e.key);
              }
              int i = indexFor(e.hash, newCapacity);
              e.next = newTable[i];
              newTable[i] = e;
              e = next;
          } // while  
      }
  }
  ```

![image-20200816101711785](C:\Users\hg\AppData\Roaming\Typora\typora-user-images\image-20200816101711785.png)

#### 为什么hashmap的长度要为2^n大小

因为hash值的取值范围是 -2^31 ~ 2^31-1，但是内存中放不下这么大的数组，所以得到的散列值还需要对数组的长度进行取余运算，这个数组下标计算的方法就是 （n-1）& hash。

**为了提高取余操作的效率** 

x % 2^n = x & (2^n-1)

为什么两者相等：

- 如果对2^n取余，从二进制的角度来看，就是得到 0 - n-1位的值，因为n位之后的都是2^n的倍数
- 2^n-1 保证了 0 - n-1 位都是1，和别的数做 & 运算，得到的就是 0 - n-1 位的值

#### 红黑树

什么时候 链表 变为 红黑树

* 链表长度到 8
* 数组长度到 64

为什么变为红黑树

红黑树相对平衡，保证查找、删除、插入的时间复杂度 最坏为 `O(log n)`，加速检索效率

红黑树特性

* 根节点是黑色
* 叶子节点是黑色
* 每个红节点的两个子节点是黑色
* 任意一节点到每个叶子节点的路径都包含相同数量的黑节点

#### hashmap扩容问题

每次扩容都是容量翻倍

当把table[i]中的所有node都迁移到newtab中的时候（原表大小为n）

- 如果 hash&n==0，则该node的位置不变
- 如果 hash&n==1，则该node的位置+n

为什么会是直接+n，这和hashmap的取余操作有关系。

假设扩容前 n为a位，n-1的低a-1位都为1，hash&n就是hash值的低a-1位

扩容之后 n变成a+1位，n-1的低a位都是1，hash&n就是hash值的低a位

这样看来，两者的差别就只有hash值第a位

- 如果hash值的第a位为0，那么扩容之后位置不变
- 如果hash值的第a位为1，那么扩容之后位置+n

#### HashMap 和 HashTable

* 线程安全：HashMap 不安全，HashTable 安全，使用 synchronized 关键字
* 效率：HashMap > HashTable
* key 和 value 对 null 的支持
  * HashMap 中 null 可以作为键，但是只能有一个；value 为 null 可以为多个
  * HashTable 不支持 null 作为键
* 初始容量 和 扩容
  * HashMap 初始 16，扩容为 2 倍。如果指定大小，则初始容量为 大于此数的 2^n
  * HashTable 初始 11，扩容为 2*n+1。如果指定大小，就是用此大小
* 底层数据结构：HashMap 在 JDK1.8 之后会变为红黑树；HashTable 不会

**为什么HashMap的value可以为空，HashTable和ConcurrentHasMmap的val都不为空**

因为HashMap的value可以为空，所以HashMap不可以通过get()方法来判断某个元素是否存在。

- 因为返回null的时候，可能是因为这个key对应的value就是null；也可能因为key不存在
- 所以需要使用contains来判断元素是否存在

```
if(map.contains(k))
    map.get(k);
else
    throw new KeyNotPresentException();
```

在多线程的条件下，可能在contians判断之后，另一个线程可能会把这个key删除

然后再用get得到的值就会为空，就可能出现并发问题

如果不允许value为空的话，就可以使用get来判断map是否包含该key，这样就没有了并发问题

#### ConcurrentHashMap 和 HashTable

* 底层结构：
  * `concurrentHashMap`：1.7  分段数组 + 链表；1.8  数组+链表/红黑树
  * `HashTable`：数组 + 链表
* 实现线程安全的方式：
  * `concurrentHashMap`：1.7 分段锁；1.8 synchronized + CAS（只锁定当前链表/红黑树的首节点）
  * `HashTable`：一把锁，使用 synchronized

#### LinkedHashMap

`LinkedHashMap` 保证了记录的顺序插入，使用 `Iterator` 遍历时，先得到的记录就是先插入的

### ArrayList

扩容机制

* 新建立的时候，是个空数组
* 执行添加元素操作时，才真正分配容量。添加第一个元素时，数组容量变为10
* 扩容后，变为之前的 1.5 倍



## 设计模式

### 单例模式

#### 饿汉

```java
public class EHan{
    private static EHan instance = new EHan();
    private EHan(){}
    public static synchronized EHan getInstance(){
        return instance;
    }
}
```

#### 懒汉

```java
public class LHan{
    private static LHan instance;
    private LHan(){}
    //synchronized 实现线程安全
    public synchronized static LHan getInstance(){
        if(instance==null)
            instance = new LHan();
        return instance;
    }
    // 这个和上面的效果一模一样，也是很容易看出和 dcl 区别的样子
    public static LHan getInstance2(){
        synchronized(LHan.class){
            if(instance==null)
                instance = new LHan();
            return instance;
        }
    }
}
```

#### 双重校验锁

```java
public class DoubleCheck{
    private volatile static DoubleCheck instance;
    private DoubleCheck(){}
    public static DoubleCheck getInstance(){
        //判断对象是否被实例化过
        if(instance==null){
            synchronized(DoubleCheck.class){
                if(instance==null){
                    instance = new DoubleCheck();
                }
            }
        }
        return instance;
    }
}
```

**和懒汉模式的区别**

* 在 `synchronized` 加锁之前，先判断是否已经实例化过了，如果实例化过了，就不在加锁。

#### 静态内部类

```java
public class StaticClass{
    private static class SingletonHolder{
        private static final StaticClass instance = new StaticClass();
    }
    private StaticClass(){}
    public static final StaticClass getInstance(){
        return SingletonHolder.instance;
    }
}
```

#### 枚举

```java
public enum MeiJu {
    INSTANCE;
    public void anyMethod(){
        System.out.println("单例模式");
    }
}
```

#### 通过反射破坏单例

静态内部类 和 双重校验锁 都可以使用反射来破坏单例

```java
//正常新建一个对象
DoubleCheck doubleCheck = DoubleCheck.getInstance();
//得到 私有的构造方法，并且指定类型 DoubleCheck
Constructor<DoubleCheck> doubleCheckConstructor = DoubleCheck.class.getDeclaredConstructor();
//允许访问静态构造方法
doubleCheckConstructor.setAccessible(true);
//实例化新的对象
DoubleCheck newDouble = doubleCheckConstructor.newInstance();
//两个不相等
System.out.println(doubleCheck.hashCode()+" "+newDouble.hashCode());
```

```java
//正常新建一个对象
StaticClass staticClass = StaticClass.getInstance();
//通过路径得到 class 对象
Class clzz = Class.forName("DesignPatten.danli.StaticClass");
//得到静态构造方法，指定返回值类型
Constructor<StaticClass> con = clzz.getDeclaredConstructor();
con.setAccessible(true);
//通过反射新建对象
StaticClass newStaticClass = con.newInstance();
System.out.println(staticClass==newStaticClass);
```

### 代理模式

#### 静态代理

可以做到在不修改目标对象的功能前提下，对目标功能扩展

缺点

* 代理对象需要 与 目标对象 实现一样的接口，所以会有很多的代理类
* 接口方法一旦增加，目标对象和代理对象都会需要维护

#### 动态代理

JDK 动态代理就是通过 接口 来实现的，需要传入 真实对象的接口

* 代理对象，不需要实现接口
* 代理对象的生成，是利用 JDK 的 API，动态的在内存中构建代理对象
* 代理对象不需要实现接口，但是目标对象一定要实现接口，否则不能使用动态代理

创建代理对象：

```java
public class test {
    public static void main(String[] args){
        //要代理的真实对象
        People people = new Teacher();

        //代理对象的调用程序，我们要把真实的对象传入代理对象的调用程序中的 构造函数中
        //最终代理对象的调用程序会调用真实对象的方法
        WorkHandler handler = new WorkHandler(people);

        //通过 Proxy类的 newProxyInstance 的方法来创建代理对象
        //第一个参数：定义由哪个类加载器对生成的代理类进行加载
        //第二个参数：给代理类对象提供一组什么样的接口
        //第三个参数：和代理对象关联的调用处理程序，需要实现 InvocationHandler 接口

        //newProxyInstance产生的实例可以被强转成 people，说明在这个方法里，我们的代理类应该继承或实现了专门创建的接口，这样才把两个类连接起来
        //在需要 继承proxy类获取有关方法 和 InvocationHandler构造方法传参  时，java不能同时继承两个类，想要和代理类建立联系，只能实现接口
        People proxy = (People) Proxy.newProxyInstance(handler.getClass().getClassLoader(), people.getClass().getInterfaces(), handler);

        proxy.say();
        System.out.println(proxy.work());
    }
}
```

调用处理程序：

```java
public class WorkHandler implements InvocationHandler {
    //要代理的真实对象
    private Object obj;

    public WorkHandler(Object obj) {
        this.obj = obj;
    }

    /*proxy：传入的代理实现类，在这里代理类和真实对象产生联系
    **method：调用对象真实的方法的method对象
    **args[]：代理对象方法传递的参数
    **/
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //再真实对象执行之间添加自己的操作
        System.out.println("before invoke");
        //实现被代理对象原有的方法
        Object invoke = method.invoke(obj, args);
        System.out.println("after invoke");
        return invoke;
    }
}
```

#### Cglib

Cglib代理：也叫子类代理。是在内存中构建一个子类对象，从而实现对目标对象功能的扩展

* 上面的 静态代理 和 动态代理，都要求目标对象 是 实现了接口(一个或多个)的目标对象
* 如果要代理没有实现接口的类，就可以使用 Cglib 实现
* Cglib是一个强大的高性能代码生成包，可以在运行期间扩展java类与java接口。广泛的应用于许多AOP框架
* Cglib的底层是通过使用一个 小而快的字节码处理框架 ASM 来转换字节码并生成新的类

Cglib子类代理的实现方法

* 需要引入 cglib 的jar文件
* 引入功能包后，就可以在内存中动态构建子类
* 代理的类不能是fainal，否则会报错
* 目标对象的方法 如果为 final、static，那么就不会被拦截，即不会执行目标对象额外的业务方法



# 多线程

## 双重检验锁实现单例模式

```
public class DoubleCheck{
    private volatile static DoubleCheck instance;
    private DoubleCheck(){}
    private synchronized static DoubleCheck getInstance(){
        //先判断对象是否已经实例过,没有实例化过才进去加锁代码
        if(instance==null){
            synchronized(DoubleCheck.class){
                if(instance==null){
                    instance = new DoubleCheck();
                }
            }
        }
        return instance;
    }
}
```

使用 `volatile` 修饰 `instance` 是为了防止指令重排,  因为 `instance = new DoubleCheck()` 分为三步来执行

- 为 `instance` 分配内存空间
- 初始化 `instance` 
- 将 `instance` 指向分配的内存地址

如果在多线程的环境下,执行顺序变为1->3->2的话,  线程T1执行了1和3, 此时T2调用 `getInstance()` 发现 `instance` 不为空

因此会返回 `instance` ,但是此时 `instance` 还未被初始化，是一个不为空但是不完整的对象

## 守护线程

Daemon  Thread

* 守护线程是一个长期驻留的服务程序，但是不希望它影响应用的退出

* JVM 发现只有守护线程存在时，将结束进程
* 必须在线程启动之前设置 `threadXXX.setDaemon(true)`

## Java中的锁

### Lock接口

lock 接口 提供了与 synchronized 关键字类似的 同步功能

* 使用时需要显示的 获取和释放 锁
* 虽然缺少了隐式获取释放锁的便捷性，但是拥有了 锁获取与释放的  可操作性、可中断的获取 以及 超时获取锁等多种 synchronized 关键字不具备的特性

Lock 接口的实现，基本都是通过 聚合了一个同步器的子类 来完成线程访问控制的

### 队列同步器（AQS）

队列同步器：AQS，用来构建 锁 或者 其他同步组件的 基础框架

* int 成员变量：表示同步状态
* 内置 FIFO 队列：完成资源获取线程的排队工作

核心思想

* 如果被请求的共享资源空闲，则将当前请求资源的线程设置为有效的工作线程，并将共享资源设置为锁定状态
* 如果被请求的共享资源被占用，那就需要一套线程阻塞等待以及被唤醒时锁分配的机制。这个机制 AQS 是使用 CLH 队列锁实现的。即将暂时获取不到锁的线程加入到等待队列中
  * CLH：虚拟的双向队列（只存在节点之间的关系，没有队列实体）

使用者 使用 同步器 需要重写同步器的指定方法，重写指定方法时，需要使用同步器提供的以下三个方法

* getState()：返回同步状态当前值
* setState(int newState)：设置同步状态
* compareAndSetState(int expect，int update)：如果当前状态为 expect，设置其为 update

AQS 对资源的共享方式

* 独占式：只有一个线程可以使用。比如：ReentrantLock
  * 公平锁：按照队列排队顺序获取锁
  * 非公平锁：无视队列排队顺序，谁抢到就是谁的
* 共享式：多个线程可以同时执行。比如：CountDownLatch、Cyclibarrier、Semaphore、ReadWriteLock

同步器提供的模板方法

* 独占式 获取与释放 同步状态
* 共享式 获取与释放 同步状态
* 查询同步队列中的线程等待情况

### 重入锁

ReentrantLock：该锁支持一个线程对资源的重复加锁

支持锁获取的公平性（可以设置 公平或非公平）

* 公平性：先对锁进行获取的请求先被满足（FIFO获取锁）
* 公平锁效率不高，但是能够减少饥饿的情况发生

实现重入

* **线程再次获取**：锁需要去识别获取锁的线程是否是当前占据锁的线程，如果是，再次获取成功
* **锁的最终释放**：线程重复获取 n 次锁，随后在 n 次释放该锁后，其他线程才能获取到该锁。
  * 锁 对于获取 进行计数自增
  * 锁 对于释放 进行计数自减

如何是实现公平

* `nonfairTryAcquire(int acquires)` 方法中，加入了 判断此节点在同步队列中是否有先驱节点
* 如果返回 true，说明 有线程比该线程 更早地请求获取锁，所以需要等待 前驱线程 获取并释放锁之后，才能继续获取锁

### 读写锁

* 在同一时刻，允许多个读线程访问
* 写线程只能有一个

#### 实现分析

* 读写状态的设计

  在一个整数上维持 读写 两个状态，就需要 “按位切割使用”。高 16 位表示读，低 16 位表示写

  读写锁通过位运算来判断 读写各自的状态

* 写锁的获取与释放

  * 写锁时支持重入的排他锁。如果当前线程已经获取了写锁，则增加写状态；如果该锁已经被获取 或者 该线程不是已经获取写锁的线程，则当前线程进入等待状态。读锁存在的时候，写锁不会被获取。可能会造成写锁饥饿。
  * 写锁释放，每次释放均 减少写状态，写状态为0 时，表示写锁被释放了

* 读锁的获取与释放

  * 只要写状态为0，读锁总能被成功的获取，增加读状态；当写锁被获取了，读线程就进入等待状态
  * 读锁每次释放，都 减少 读状态

* 锁降级：写锁降级为读锁

### Condition

实现等待通知模式

* `wait notify + synchronized`  
* `condition + lock`

`condition` 的使用

* Condition 对象 是由 Lock 对象创建出来的 `lock.newCondition()`
* `condition.await()`：线程调用此方法后，当前线程会释放锁，在此等待
* `condition.signal()`：线程调用此方法，通知等待线程从 await 方法返回，返回前已经获得了锁

## 线程间合作

### 关键字

1. volatile 关键字
   * 告知程序所有对该变量的访问，都需从共享内存中获取；所有对它的改变，都需要同步刷新回共享内存，保证所有线程对变量访问的可见性
   * 过多的使用 volatile 关键字，会降低程序执行效率
2. synchronization 关键字
   * 保证多个线程在同一时刻，只能有一个线程处于方法或者同步块之中
   * 保证线程对变量访问的可见性和排他性
   * 同步方法或者同步块，本质都是对 **对象的监视器** 进行获取（任何对象都有自己的监视器）

### 等待/通知机制

使用`wait() notify() notifyAll()`时需要注意的细节

* 使用这些方法之前，应该 先对调用对象 **加锁**
* 调用 `wait()` 方法后，线程状态由 `RUNNING` 变为 `WAITING`，并将当前线程放置到对象的等待队列
* `notify()` 或`notifyAll() `调用之后，等待线程不会从 `wait` 返回，需要调用`notify() notifyAll()`的线程释放锁之后，等待线程才有机会从 `wait()` 返回
* `notify()` 是将等待队列中的一个等待线程从等待队列中移动到同步队列中；`notifyAll()` 是将等到队列中的所有线程全部移动到同步队列。被移动的线程状态由 `WAITING` 变为 `BLOCKED`
* 从 `wait()` 方法返回的前提是，获得了调用对象的锁

### 等待/通知经典范式

等待方：

* 获取对象锁

* 如果条件不满足，调用对象的`wait()`方法，被通知后仍要检查条件

* 条件满足则执行对应的逻辑

  ```java
  synchronized(对象){
      while(条件不满足){
          对象.wait();
      }
      对应的处理逻辑
  }
  ```

通知方：

* 获得对象的锁

* 改变条件

* 通知所有等待在对象上的线程

  ```java
  synchronized(对象){
      改变条件;
      对象.notifyAll();
  }
  ```


### 管道输入/输出流

管道输入/输出流：用于线程之间的数据传输，传输的媒介为内存

* `PipedOutputStream、PipedInputStream`：面向字节

* `PipedReader、PipedWriter`：面向字符

  ```java
  PipedWriter out = new PipedWriter();
  PipedReader in = new PipedReader();
  //输入流和输出流进行连接
  out.connect(in);
  ……
  //写数据
  out.write(数据);
  
  new Thread -> run(){
      //读数据
      in.read();
  }
  ```

### Thread.join

线程A执行 `thread.join()`语句：当前线程 A 等待 Thread 线程终止之后才会从 `thread.join()` 返回

```java
public final synchronized void join() throws InterruptedException{
    //条件不满足，继续等待
    while(isAlive()){
        wait(0);
    }
    //条件符合，方法返回
}
```

### ThreadLocal

线程变量：ThreadLocal为键、任意对象为值 的存储结构

## Java并发容器和框架

### ConcurrentHashMap

`ConcurrentHashMap` 是线程安全且高效的 HashMap

* 多线程环境下，使用 HashMap 进行 put 操作 会引起死循环
* HashTabel 使用 synchronized 来保证线程安全。在线程激烈竞争的情况下，效率十分低下
* `ConcurrentHashMap`  的分段所 锁技术，可以有效的提高并发效率

`ConcurrentHashMap`  的数据结构

* `Segment[]`：可重入锁，在 `ConcurrentHashMap` 中扮演锁的角色
  * 一个 `ConcurrentHashMap`  包含一个 `Segment` 数组，是一种数组和链表结构
* `HashEntry[]`：用于存储键值对数据
  * 每个 `Segment` 守护着一个 `HashEntry` 数组里的元素，当对 `HashEntry` 进行修改时，必须先获得与它对应的 `Segment` 锁



JDK 1.8 之后

`ConcurrentHashMap`  变为了 数组+链表/红黑树

使用 synchronized + CAS 来实现 线程安全（有几个链表，就有几把锁）

### ConcurrentLinkedQueue

并发编程的线程安全队列

* 阻塞算法：加锁
* 非阻塞算法：循环 CAS

`ConcurrentLinkedQueue` 结构

* `ConcurrentLinkedQueue`  由 head 节点 和 tail 节点 组成
* 每个节点 由 节点元素+指向下一个节点的引用 组成

队列操作

* 入队列：将入队节点 添加到 队列尾部
  * 将入队节点 设置为成 当前队列尾结点的下一个节点
    * 定位尾结点：判断 tail 节点是否有 next 节点
  * 更新 tail 节点
    * 若 `tail节点的next节点` 不为空：将入队节点 设置为 tail 节点
    * 若为空：将入队节点 设置为  `tail的next节点`
    * 所以 tail 节点 并不总是 尾结点
  * 多线程环境下
    * 先获取尾结点，然后设置尾结点的下一个节点为入队节点
    * 如果有另一个线程插队，尾结点就会发生变化（不为空），当前线程暂停入队操作，重新获取尾结点
* 出队列：并不是每次都会更新 head 节点
  * 当 head 节点里有元素时：直接弹出 head 节点内的元素
  * 没有元素时：出队列更新 head 操作

为什么 tail 节点不总是尾结点，head 节点不总为头节点？

如果每次都使 tail 节点作为尾结点，每次插入都需要使用 CAS 循环去更新 tail 节点

* 如果能够减少 tail 的更新次数，就能提高入队效率。所以使用 HOPS 变量来减少 tail 的更新频率
  * 当 tail 节点 到尾结点 的值 >= HOPS 时，才更新 tail 节点
  * 但是距离边长的结果就是，每次定位 尾结点 的耗时增加
  * 但是效率依旧有提升，因为本质是使用 volatile 的读操作，替代了 volatile 的写操作

### 阻塞队列

支持两个附加操作的队列，常用于 生产者和消费者 场景

* 阻塞插入：队列满时，队列会阻塞插入元素的线程，直至队列不满
* 阻塞移除：队列为空时，获取元素的线程会等待队列变为非空

JDK 提供的阻塞队列

* `ArrayBlockingQueue`：数组结构，有界阻塞队列
  * 默认是不公平的
  * 可以使用 可重入锁 实现访问者的公平性
* `LinkedBlockingQueue`：链表结构，有界阻塞队列
  * 默认长度是 Integer.MAX_VALUE
* `PriorityBlockingQueue`：支持优先级排序，无界阻塞队列
  * 默认情况下元素采取自然序列升序排列
  * 也可以自定义实现 `compareTo()`来对指定元素排序规则
* `DelayQueue`：支持延迟获取，无界阻塞队列（使用优先级队列实现）
  * 支持延时获取元素，队列使用 `PriorityQueue` 来实现
  * 队列中的元素必须实现 `Delayed` 接口，创建元素时可以指定多久才能从队列中获取当前元素
* `SynchronousQueue`：不存储元素的 阻塞队列
  * 一个 put 操作，必须等待一个 take 操作
  * 默认非公平，但是支持公平访问
* `LinkedTransferQueue`：由链表结构组成的 无界阻塞队列
  * `transfer`：如果有消费者，立即传递给消费者；如果没有，将元素放在队列的 tail 节点
  * `tryTransfer`：试探生产者传入的元素是否可以 直接传递给消费者
* `LinkedBlockingDeque`：由链表结构组成的 双向阻塞队列

阻塞队列实现原理

* 使用 通知模式
* `ArrayBlockingQueue` 中使用了 `Condition` 来实现

##  Java中的并发工具类

### CountDownLatch

#### CountDownLatch

`countDownLatch` 像是一个计数器，线程完成一个记录一个，计数器递减，只能使用一次。

可以用来控制线程按顺序执行，主要有以下几个方法：

```
//构造方法，count是计数器的初值
public CountDownLatch(int count) {};
//调用await()方法的线程会被挂起，它会等待直到count值为0才继续执行
public void await() throws InterruptedException { };   
//和await()类似，只不过等待一定的时间后count值还没变为0的话就会继续执行
public boolean await(long timeout, TimeUnit unit) throws InterruptedException { };  
//将count值减1
public void countDown() {};
```

#### join()方法

使用 `thread.join()` 方法也可以达到控制线程，按顺序执行的目的

```
threadA.start();
threadA.join();
…………B…………
```

join的成员方法加了synchronized关键字，说明是`synchronized(this)`，this是谁啊？this就是threadA子线程对象本身。也就是说， **调用join()方法的线程** 持有了threadA这个对象的锁。

只有当子线程threadA执行完毕的时候，jvm会自动唤醒（`lock.notify_all(thread)` ）阻塞在threadA对象上的线程，才会继续执行B部分的代码。

### Cyclicbarrier

`Cyclicbarrier`：可循环使用的屏障

* 让一组线程到达屏障点时被阻塞
* 直到最后一个线程到达屏障时，屏障才会开门，所有被屏障拦截的线程才会继续运行

```java
//构造方法，参数表示被屏障拦截的线程数
public CyclicBarrier(int parties){}
//await方法，线程调用 await 方法，告诉 cyclicBarrier 自己已经到达屏障
//返回值是 还需要被拦截的线程数量
public int await() throws InterruptedException, BrokenBarrierException{}

//一个更高级的构造函数。在所有线程都到达屏障之后，优先执行 barrierAction
public CyclicBarrier(int parties, Runnable barrierAction){}
```

#### Cyclicbarrier 和 CountDownLatch 的区别

* `countDownLatch`  只能使用一次
* `Cyclicbarrier`  ：提供了更多的方法 
  *  `reset` 方法可以进行重置
  *  `getNumberWaiting` 来获取阻塞的线程数量
  * `isBroken`  来了解阻塞的线程是否被中断

### Semaphore

`Semaphore` 是用来控制同时访问特定资源的线程数量

* `public Semaphore(int permits)`：构造方法，可用的许可证数量，也就是最大并发数
* `acqure()`：获取许可证
* `release()`：归还许可证
* `tryAcquire()`：尝试获取许可证
* `intavaliablePermits()`：返回此信号量中，当前等待可用的许可证数
* `intgetQueueLength()`：返回正在等待 获取许可证的线程数

### Exchanger

用于线程协作的工具类

* 提供一个同步点，两个线程可以彼此交换数据
* 如果一个线程线执行了 `exchange()` 方法，它会一直等待第二个线程执行 `exchange()`
* 只有两个到达了同步点，才会交换数据

## 新建线程的三种方式

用并发编程实现加法，主要步骤有三个

- 分解任务
- 新建线程执行子任务
- 合成子结果为最终结果

### 继承thread类（无返回值）

```
public class SumThread extends Thread {
    private long start;
    private long end;
    private int num;
    private long[] result;
    private CountDownLatch cdl;

    public SumThread(long start, long end, int num, long[] result, CountDownLatch cdl) {
        this.start = start;
        this.end = end;
        this.num = num;
        this.result = result;
        this.cdl = cdl;
    }
    //需要重写run方法
    @Override
    public void run() {
        long sum = 0;
        for (long i=start;i<end;i++){
            sum += i;
        }
        result[num] = sum;
        //计数器减一
        cdl.countDown();
    }
}
public class SumParallelThread {
    public static void main(String[] args) throws InterruptedException{
        int N = 90000000;
        int numThread = 3;
        parallel(N, numThread);
    }
    public static void parallel(int N, int numThread) throws InterruptedException{
        //通过一个数组来记录各个子线程的计算结果
        long[] result = new long[numThread];
        //CountDownLatch可以看作计数器
        CountDownLatch cdl = new CountDownLatch(numThread);
        long start = System.currentTimeMillis();
        for (int i=0;i<numThread;i++){
            //新建线程，并执行
            SumThread thread = new SumThread(i*N/numThread, (i+1)*N/numThread, i, result, cdl);
            thread.start();
        }
        //等待所有线程执行完毕，在进行最后的加法
        cdl.await();
        long sum = 0;
        for (long r : result)
            sum += r;
        long end = System.currentTimeMillis();
        System.out.println("并行计算结果："+sum);
        System.out.println("并行计算时间："+(end-start)+"ms");
    }
}
```

### 实现Runable接口（无返回值）

```
public class SumThreadRunnable implements Runnable {
    private long start;
    private long end;
    private long[] result;
    private CountDownLatch cdl;
    private int num;
    public SumThreadRunnable(long start, long end, long[] result, CountDownLatch cdl, int num){
        this.start = start;
        this.end = end;
        this.result = result;
        this.cdl = cdl;
        this.num = num;
    }
    //重写run方法
    @Override
    public void run() {
        long sum = 0;
        for (long i=start;i<=end;i++){
            sum += i;
        }
        result[num] = sum;
        cdl.countDown();
    }
}
public class SumParallelRunnable {
    public static void main(String[] args) throws InterruptedException{
        int N = 90000000;
        int numThread = 3;
        countDownLatchSum(N, numThread);
    }
    public static void countDownLatchSum(int N, int numThread) throws InterruptedException{
        long start = System.currentTimeMillis();
        CountDownLatch cdl = new CountDownLatch(numThread);
        //和上一个一样，使用一个数组来保存子线程的计算结果
        long[] result = new long[numThread];
        long sum = 0;
        for (int i=0;i<numThread;i++){
            //runable作为target去新建线程，调用start方法执行子线程
            new Thread(new SumThreadRunnable(i*N/numThread, (i+1)*N/numThread, result, cdl, i)).start();
        }
        cdl.await();
        for (long r : result)
            sum += r;
        long end = System.currentTimeMillis();
        System.out.println("并行计算耗时："+(end-start)+"ms");
        System.out.println("并行计算结果："+sum);
    }
}
```

### 实现Callable接口和Future（有返回值）

* 创建Callable接口的实现类，并实现call()方法，该call()方法将作为线程执行体，并且有返回值

* 创建Callable实现类的实例

  * 使用 线程池 和 Future

    * `Future<Long> a = executor.submit(new SumThreadCallable(i*N/numThread, (i+1)*N/numThread));`
    * `Long num = a.get()`

  * 使用 FutureTask

    * `FutureTask<Long> task = new FutureTask<Long>(new SumThreadCallable(i*N/numThread, (i+1)*N/numThread));`

      使用FutureTask类来包装Callable对象，FutureTask对象封装了该Callable对象的call()方法的返回

    * `new Thread(task).start();`

      使用FutureTask对象作为Thread对象的target创建并启动新线程

    * `Long a = task.get()`

      调用FutureTask对象的get()方法来获得子线程执行结束后的返回值

```
public class SumThreadCallable implements Callable<Long> {
    private long start;
    private long end;
    public SumThreadCallable(long start, long end){
        this.start = start;
        this.end = end;
    }
    //重写call方法，会有返回值
    @Override
    public Long call() throws Exception {
        long sum = 0;
        for (long i=start;i<end;i++){
            sum += i;
        }
        return sum;
    }
}
public class SumParallelCallable {
    public static void main(String[] args) throws ExecutionException, InterruptedException {
        int numThread = 3;
        int N = 90000000;
        parallel(N, numThread);
    }
    public static void parallel(int N, int numThread) throws ExecutionException, InterruptedException{
        //新建线程池
        ExecutorService executor = Executors.newFixedThreadPool(numThread);
        long start1 = System.currentTimeMillis();
        //使用Future记录返回值
        List<Future<Long>> ans = new ArrayList<>();
        for (int i=0;i<numThread;i++){
            //使用submit向线程池提交线程，会有返回值
            //使用execute提交没有返回值
            Future<Long> a = executor.submit(new SumThreadCallable(i*N/numThread, (i+1)*N/numThread));
            ans.add(a);
        }
        long sum = 0;
        for (Future<Long> i : ans){
            long tmp = i.get();
            System.out.println("线程"+i+"的结果是："+tmp);
            sum += tmp;
        }
        long end1 = System.currentTimeMillis();
        System.out.println("并行计算耗时："+(end1-start1)+"ms");
        System.out.println("并行计算结果："+sum);
    }
}
```

## 线程池

### 为什么使用线程池

- 降低资源消耗 :  创建/销毁线程会有系统开销，过于频繁的创建/销毁线程，会很大程度影响处理效率
- 提高响应速度 :  线程并发数量过多，会抢占系统资源造成阻塞
- 提高线程的可管理性 :  对线程进行一些简单的管理（延迟执行、定时循环执行）

### 线程池参数

新建一个线程池：`ThreadPoolExecutor threadPool = new ThreadPoolExecutor(各种参数)`

- corePoolSize：核心线程数的最大值
- maximumPoolSize：线程总数最大值
- keepAliveTime：非核心线程闲置超时时长
- TimeUnit：时间枚举类型
- BlockingQueue<Runnable>：任务队列
- ThreadFactory：创建线程的方式
- RejectedExecutionHandler：抛出异常的方式（拒绝策略）

### 线程池状态

- RUNNING：创建线程池，初始时，处在此状态
- SHUTDOWN：调用shutdown()方法，处于此状态，此时不接收新任务，但是会等待所有任务执行完毕
- STOP：调用shutdownNow()方法，处于此状态，此时不接收新任务，并且尝试终止正在执行的任务
- TIDYING：处于SHUTDOWN或STOP状态，并且所有工作线程都销毁，任务缓存队列清空或执行结束后，线程池会处在此状态
- TERMINATED：在执行 `terminated()` 方法之后会进入到此状态

### 线程提交策略

execute()：提交一个任务，没有返回值

submit()：提交一个线程任务，有返回值

`ThreadPoolExecutor.execute(Runnable command)` ：向线程池中添加一个任务

- 如果线程数未达到核心线程数，就新建核心线程来处理任务
- 如果达到核心线程数，就把把来的任务加入缓存队列中
- 如果队列已满，就新建非核心线程来执行任务
- 如果线程数达到maximumPoolSize，再进来新的任务就会抛出异常
- 如果线程数大于corePoolSize，若某线程的空闲时间大于keepAliveTime，线程就将被终止，直至线程数等于corePoolSize。如果允许为核心线程设置存活时间，那么核心线程的空闲时间大于keepAliveTime的时候，也会被终止

### 排队策略

- SynchronousQueue：这个队列不会保留任务，每次收到任务，就会直接提交给线程处理，如果所有的线程都在工作，那就会新建一个线程来处理任务。
- LinkedBlockingQueue：链表有界阻塞队列，当接收到任务时，如果当前线程数小于核心线程数，就新建核心线程处理任务。如果当前线程数等于核心线程数，就进入队列等待，这个队列的长度没有限制，会导致maximumPoolSize失效。
- ArrayBlockingQueue：限定长度的队列，当接收到任务时，如果当前线程数小于核心线程数，就新建核心线程处理任务。如果当前线程数等于核心线程数，任务就进入等待队列，如果等待队列满了，就新建非核心线程处理任务，直到任务数达到maximumPoolSize。如果此时还有任务加入，就会抛出异常
- DelayQueue：队列内的元素必须实现Delayed接口，这就意味着传进去的任务必须先实现Delayed接口。当这个队列接收到任务时，首先会入队，达到指定延时时间之后，才会执行任务。

### 拒绝策略

当线程池中的缓存队列已满，而且线程数达到maximumPoolSize，如果还有新的任务到来，就会执行拒绝策略

简单来说， **线程数>最大线程数+缓存队列时，会触发拒绝策略** 

- ThreadPoolExecutor.AbortPolicy：丢弃新到来的任务，并抛出RejectedExecutionException
- ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常
- ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新尝试执行任务（重复此过程）
- ThreadPoolExecutor.CallerRunsPolicy：使用调用者线程(提交任务的线程)来处理任务。可能会降低新任务的提交速度，影响整体性能。这个策略还喜欢增加队列容量。

### 线程池关闭

- shutdown()：不会立即终止线程池，而是要等到缓存队列中的任务都执行完之后才终止，但是不会接收新任务
- shutdownNow()：立即终止线程池，尝试打断正在执行的任务，清空任务缓存队列，返回尚未执行的任务

### Java提供的线程池

| 方法                 | corePoolSize | maximumPoolSize   | keepAliveTime | workQueue           |
| -------------------- | ------------ | ----------------- | ------------- | ------------------- |
| CachedThreadPool     | 0            | Integer.MAX_VALUE | 60s           | SynchronousQueue    |
| FixedThreadPool      | nThreads     | nThreads          | 0             | LinkedBlockingQueue |
| SingleThreadExecutor | 1            | 1                 | 0             | LinkedBlockingQueue |
| ScheduledThreadPool  | corePoolSize | Intger.MAX_VALUE  | 0             | DelayQueue          |

### 如何配置线程池大小

- CPU密集型：使用较小的线程池，一般为 核心数+1
- IO密集型：一般为 2*核心数
- 混合型任务：将任务分为IO密集型和CPU密集型，交给不同的线程池去处理。只要分别执行的时间数量级相差不大，就会比串行执行更高效。

## ThreadLocal

ThreadLocal提供了线程内存储变量的能力,  每一个线程读取的变量是对应且相互独立的.

- 对于某一个 `ThreadLocal` 来讲,他的索引值 `i` 是确定的, 在不同的线程间访问时,  访问的是不同 `table` 数组的同一位置, 即都是 `table[i]` , 只不过不同线程之间的 `table` 是互相独立的
- 对同一线程的不同 `ThreadLocal` 来讲, 这些 `ThreadLocal` 共享一个实例 `table` 数组,  然后每个 `ThreadLocal` 实例在 `table` 中的索引 `i` 是不同的

`ThreadLocal` 的静态内部类 `ThreadLocalMap` 为每个 `Thread` 都维护了一个 `Entry`数组`table` ,  `ThreadLocal` 确定了一个数组下标,  而这个下标就是 `value` 存储的对应的位置.

### 如何定位到threadlocal的位置

在ThreadLocalMap中的set方法与构造方法都能看到以下字段

```
int i = key.threadLocalHashCode & (len-1)
int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY-1)
```

通过计算索引值，从数组中对应位置取值

索引值如何计算的：在 `new ThreadLocal()` 时，因为 `threadLocalHashCode` 的初始化，会使 `threadLocalHashCode` 值自增一次，增量为 `0x61c88647` 

这个增量是斐波那契散列乘数，优点是通过它hash出来的结果会比较均匀，可以最大限度的减少散列冲突

### ThreadLocal.set()方法

```
//set 方法
public void set(T value) {
      //获取当前线程
      Thread t = Thread.currentThread();
      //获得此线程的ThreadLocalMap (实际存储的数据结构类型,每个线程都有一个)
      ThreadLocalMap map = getMap(t);
      //如果存在map就直接set，没有则创建map并set
      if (map != null)
          map.set(this, value);
      else
          createMap(t, value);
  }
  
//getMap方法
ThreadLocalMap getMap(Thread t) {
      //thred中维护了一个ThreadLocalMap, threadLocals是线程内的一个变量
      return t.threadLocals;
 }
 
//createMap
void createMap(Thread t, T firstValue) {
      //实例化一个新的ThreadLocalMap，并赋值给线程的成员变量threadLocals
      //实例化ThreadLocalMap,就是要创建一个Entry数组
      t.threadLocals = new ThreadLocalMap(this, firstValue);
}
```

`ThreadLocalMap.set()` 方法（解决冲突用的是开放定址法，hashmap用的是链表）

- 获取索引值
- 遍历tab,  如果存在就更新值（如果索引处不是这个值，就要继续向下找）
- 如果没有遍历成功,  就创建值

### ThreadLocalMap

```
//Entry为ThreadLocalMap静态内部类，对ThreadLocal的弱引用(这里可能导致内存泄漏)
//同时让ThreadLocal和储值形成key-value的关系
static class Entry extends WeakReference<ThreadLocal<?>> {
    /** The value associated with this ThreadLocal. */
    Object value;
    Entry(ThreadLocal<?> k, Object v) {
           super(k);
           value = v;
    }
}

//ThreadLocalMap构造方法
ThreadLocalMap(ThreadLocal<?> firstKey, Object firstValue) {
        //内部成员数组，INITIAL_CAPACITY值为16的常量
        table = new Entry[INITIAL_CAPACITY];
        //位运算，结果与取模相同，计算出需要存放的位置(在table数组中存放的位置)
        //threadLocalHashCode比较有趣
        int i = firstKey.threadLocalHashCode & (INITIAL_CAPACITY - 1);
        table[i] = new Entry(firstKey, firstValue);
        size = 1;
        setThreshold(INITIAL_CAPACITY);
}
```

### ThreadLocal.get()

```
//ThreadLocal中get方法
public T get() {
    //得到当前的线程
    Thread t = Thread.currentThread();
    //得到 ThreadLocalMap
    ThreadLocalMap map = getMap(t);
    if (map != null) {
        ThreadLocalMap.Entry e = map.getEntry(this);
        if (e != null) {
            @SuppressWarnings("unchecked")
            T result = (T)e.value;
            return result;
        }
    }
    return setInitialValue();
}
    
//ThreadLocalMap中getEntry方法
//通过计算索引得到数组中的下标
private Entry getEntry(ThreadLocal<?> key) {
       int i = key.threadLocalHashCode & (table.length - 1);
       Entry e = table[i];
       if (e != null && e.get() == key)
            return e;
       else
            return getEntryAfterMiss(key, i, e);
}
```

### 内存泄漏

![image-20200804093953691](C:\Users\hg\AppData\Roaming\Typora\typora-user-images\image-20200804093953691.png)

原因:

- `ThreadLoaclMap` 中的 `key` 是 `Thread Local` 的弱引用,  而 `value` 是强引用.
- 如果 `ThreadLocal` 如果没有被外部强引用,  在垃圾回收时, `key` 会被清理掉, 而 `value` 不会被清理
- 这样就会出现 `key` 为空,的 `Entry` , `value` 永远无法被回收, 就可能产生内存泄漏

措施: **废弃项目的移除 依赖于显示地触发，否则就要等到线程结束** 

- `ThreadLocal` 在调用 `set() get() remove()` 方法时,  会清理掉 `key` 为空的记录
- 使用完 `ThreadLocal` 后,  最好手动调用 `remove()` 方法

## Atomic原子类

原子类的位置：`java.util.concurrent.atomic` 

* 基本类型
  * `AtomicInteger`
  * `AtomicLong`
  * `AtomicBoolean`
* 数组类型
  * `AtomicIntegerArray`
  * `AtomicLongArray`
  * `AtomicReferenceArray`
* 常用方法
  * `get()`
  * `getAndSet(int newValue)`
  * `getAndIncrement`()
  * `getAndDecrement()`
  * `getAndAdd(int delta)`
  * `compareAndSet(int expect, int update)`
  * `lazySet(int newValue)`：延迟获取
* `AtomicInteger` 基本原理
  * CAS + volatile 和 native 方法

## 线程、进程、线程池的状态

### 进程的几种状态

- 创建：为一个新进程创建PCB（进程控制块，它是系统为了管理进程设置的一个专门的数据结构，主要表示进程的状态），把该进程转入到就绪状态并插入到就绪队列之中
- 就绪：当进程已分配到除CPU以外的所有必要资源后，只要再获得CPU，便可立即执行，这种状态是就绪状态
- 执行：进程已获得CPU，其程序正在执行
- 阻塞：正在执行的进程由于发生某事件而暂时无法继续执行时，便放弃CPU而处于暂停状态，亦即进程的执行受到阻塞，把这种暂停状态称为阻塞状态
- 终止：等待操作系统进行善后处理，然后将其PCB清零，并将PCB空间返还系统

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1102741/1593476505274-59341dad-449a-47fe-82d7-9dea77e28a52.png)

有些还会具有挂起状态，具有挂起状态的转换图如下：

引起挂起的原因有：

-  终端用户的请求：当终端用户在自己的程序运行期间发现有可疑问题时，希望暂时使自己的程序静止下来。
- 父进程请求：有时父进程希望挂起自己的某个子进程，以便考查和修改该子进程，或者协调各子进程间的活动。
- 负荷调节的需要。当实时系统中的工作负荷较重，已可能影响到对实时任务的控制时，可由系统把一些不重要的进程挂起，以保证系统能正常运行。
- 操作系统的需要。操作系统有时希望挂起某些进程，以便检查运行中的资源使用情况或进行记账。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1102741/1593479321180-349f2ef1-5140-4c59-9994-502dc21920c1.png)

### 线程的几种状态

- 初始：
- 运行：
- 等待：
- 阻塞：
- 终止：

![img](https://cdn.nlark.com/yuque/0/2020/jpeg/1102741/1593479483073-7197f320-80ac-418a-a108-d741893245a7.jpeg)

### 线程池的几种状态

- RUNNING：创建线程池，初始时，处在此状态
- SHUTDOWN：调用shutdown()方法，处于此状态，此时不接收新任务，但是会等待所有任务执行完毕
- STOP：调用shutdownNow()方法，处于此状态，此时不接收新任务，并且尝试终止正在执行的任务
- TIDYING：处于SHUTDOWN或STOP状态，并且所有工作线程都销毁，任务缓存队列清空或执行结束后，线程池会处在此状态
- TERMINATED：在执行 `terminated()` 方法之后会进入到此状态

## 面试问题

### 线程是否可以两次 start

两次 start 同一个线程之后，会 抛出异常 `IllegalThreadStateException`

### Start() 和 Run() 的区别

在Java中，线程一般有五种状态：创建、就绪、阻塞、运行、死亡

* start()：生成线程对象之后，调用线程的start方法后，该线程就进入了就绪状态。但是此时的线程调度程序，还没把该线程设置为当前线程
* run()：线程处于运行状态，运行 run 中的代码

调用 start 之后，线程会被放到 **等待队列** ，等待 CPU 的调度，并不一定要马上开始执行，只是至于 就绪状态。

然后通过 JVM，线程 thread 会调用 run 方法，执行本线程的线程体

* 使用 start() 方法，真正的实现了多线程调用。无需等待 run 方法执行结束，就可以继续执行后面的代码
* 使用 run() 方法，可以理解为调用了一个普通的函数。线程还是要顺序执行，只有执行完 run 方法体中的内容后，才会执行后面的代码。程序中还是只有主线程这一条线程。

### sleep() 和 wait()

* 最大的区别在于：sleep 方法没有释放锁；wait 方法释放了锁
* 都可以用于暂停线程的执行
* wait 常被用于线程之间的交互通信；sleep 常用于暂停线程
* wait() 方法被调用之后，线程不会自动苏醒，需要别的线程调用 同一个对象上的 notify() 或者 notifyAll() 方法；sleep() 方法执行后，会自动苏醒。（或者可以使用 wait(long time) 超时等待后会自动苏醒）

### synchronized 和 ReentrantLock

* 两者都是可重入锁
* synchronized 依赖于 JVM，ReentrantLock 依赖于 API
  * synchronized 是依赖于 JVM，对用户是透明的
  * ReentrantLock 是依赖于 JDK 的，需要 lock 和 unlock 实现
* ReentrantLock 的高级功能
  * 等待可中断：`lock.lockInterruptibly()` 来实现。等待的线程可以选择放弃等待
  * 可实现公平锁：按照 FIFO 顺序获取锁
  * 可实现选择性通知：通过 `Condition`。
    * 和 `synchronized + wait notify` 比起来，`condition` 具有更好的灵活性
    * 线程对象可以注册在指定的`condition`上，从而有选择性的进行线程通知，线程调度更加灵活
    * synchronized 相当于整个对象，只有一个 condition 实例

### Lock 和 tryLock 的区别

* `Lock()`：如果未获取到锁，会一直等待，即使调用`interrupt()` 方法也不会中断；只能等待资源被释放
* `lockInterruptibly()`：可以调用 `interrupt()`  中断线程
* `tryLoak()`：获取不到锁就会返回 false，继续执行后面的代码

### Thread 和 Runnable

* thread 是类，runnable 是接口。Java 不允许类多继承
* Runnable可以实现多个相同的程序代码的线程去共享同一个资源，thread 不适合

# JavaWeb

## SpringBoot

### Bean生命周期

四个阶段：实例化、属性赋值、初始化、销毁

* 资源定位：`@ComponentScan` 所定义的扫描路径，去找到带有 `@Component` 的类

* Bean 定义：一旦找到资源，就开始解析，将定义的信息保存起来

* 发布 Bean 的定义：把 Bean 定义发布到 Spring IOC 容器，IOC 中只有Bean定义，没有实例

* 实例化：创建 Bean 的实例对象

  

* 依赖注入：例如 `@Autowired` 注入的各种资源

* 如果Bean实现了BeanNameAware接口的话，Spring将Bean的Id传递给setBeanName()方法

* 如果Bean实现了BeanFactoryAware接口的话，Spring将调用setBeanFactory()方法，将BeanFactory容器实例传入

* 如果Bean实现了ApplicationContextAware接口的话，Spring将调用Bean的setApplicationContext()方法，将bean所在应用上下文引用传入进来。

  

* BeanPostProcessor的预初始化方法（对所有bean生效），Spring调用postProcessBeforeInitialization()方法。

* 如果使用了 @PostConstruct 标注方法，就会使用自己的自定义初始化方法

* 如果Bean 实现了InitializingBean接口，Spring将调用他们的afterPropertiesSet()方法。类似的，如果bean使用init-method声明了初始化方法，该方法也会被调用

* BeanPostProcessor的后初始化方法（对所有bean生效），Spring调用 postProcessAfterInitialization()方法。

* 此时，Bean已经准备就绪，可以被应用程序使用了。他们将一直驻留在应用上下文中，直到应用上下文被销毁。

  

* 使用 @PreDestroy 标注的方法，会使用自定义的销毁方法

* 如果bean实现了DisposableBean接口，Spring将调用它的destory()接口方法，同样，如果bean使用了destory-method 声明销毁方法，该方法也会被调用。

### AOP

#### 动态代理实现AOP

```
//动态代理类的  调用处理程序 都必须继承 InvocationHandler 接口
public class WorkHandler implements InvocationHandler {
    //要代理的真实对象
    private Object obj;

    public WorkHandler(Object obj) {
        this.obj = obj;
    }

    /*proxy：传入的代理实现类，在这里代理类和真实对象产生联系
    **method：调用对象真实的方法的method对象
    **args[]：代理对象方法传递的参数
    **/
    @Override
    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {
        //再真实对象执行之间添加自己的操作
        System.out.println("before invoke");
        //实现被代理对象原有的方法
        Object invoke = method.invoke(obj, args);
        System.out.println("after invoke");
        return invoke;
    }
}


public class test {
    public static void main(String[] args){
        //要代理的真实对象
        People people = new Teacher();

        //代理对象的调用程序，我们要把真实的对象传入代理对象的调用程序中的 构造函数中
        //最终代理对象的调用程序会调用真实对象的方法
        InvocationHandler handler = new WorkHandler(people);

        //通过 Proxy类的 newProxyInstance 的方法来创建代理对象
        //第一个参数：定义由哪个类加载器对生成的代理类进行加载
        //第二个参数：给代理类对象提供一组什么样的接口
        //第三个参数：代理对象 关联的 调用处理程序

        //newProxyInstance产生的实例可以被强转成 people，说明在这个方法里，我们的代理类应该继承或实现了专门创建的接口，这样才把两个类连接起来
        //在需要 继承proxy类获取有关方法 和 InvocationHandler构造方法传参  时，java不能同时继承两个类，想要和代理类建立联系，只能实现接口
        //Proxy路径：java.lang.reflect.Proxy
        People proxy = (People) Proxy.newProxyInstance(handler.getClass().getClassLoader(), people.getClass().getInterfaces(), handler);

        System.out.println(proxy.work());
    }
}
```

#### 动态代理

- jdk：被代理的类必须是实现某个接口
- cglib：可以直接对实现类进行操作而非接口

## SpringMvc中的注释

```java
@Controller
@RequestMapping("/brand")
public class PmsBrandController{
    @Autowired
    private PmsBrandService demoService;

    @RequestMapping(value = "listAll", method = RequestMethod.GET)
    @ResponseBody
    public CommonResult<List<PmsBrand>> getBrandList() {
        List<PmsBrand> pmsBrands = demoService.listAllBrand();
        System.out.println(demoService.listAllBrand());
        return CommonResult.success(demoService.listAllBrand());
    }

    @RequestMapping(value = "/update/{id}", method = RequestMethod.POST)
    @ResponseBody
    public CommonResult updateBrand(@PathVariable("id") Long id, @RequestBody PmsBrand pmsBrandDto, BindingResult result) {
        CommonResult commonResult;
        System.out.println(demoService.getBrand(id));
        int count = demoService.updateBrand(id, pmsBrandDto);
        if (count == 1) {
            commonResult = CommonResult.success(pmsBrandDto);
            LOGGER.debug("updateBrand success:{}", pmsBrandDto);
        } else {
            commonResult = CommonResult.failed("操作失败");
            LOGGER.debug("updateBrand failed:{}", pmsBrandDto);
        }
        return commonResult;
    }
}
```

* `@RequestMapping`
  * 作用：处理请求地址的映射
  * 范围：类上可以有，方法上必须有（通过此映射路径来寻找方法）
  * `getBrandList()`的路径是`/brand/listAll`：类路径+方法路径
* `@ResponsetBody`
  * 范围：作用在方法上
  * 作用：将方法的返回结果写入Http响应正文（ResponseBody）中，一般在获取数据时使用
    * 如果不使用此注解，在使用`@RequestMapping`后，返回值会解析为`跳转路径`
    * 如果使用此注解，不会被解析为跳转路径，会直接写入Http响应正文
  * `getBrandList()`方法会返回json数据
* `@RequestBody`
  * 用于读取Request请求的body部分，使用系统默认配置的HttpMessageConverter进行解析，然后把相应的数据绑定到要返回的对象上
  * 再把HttpMessageConverter返回的对象数据绑定到controller中的方法参数上
  * `updateBrand()`方法中，使用`@RequestBody`把`PmsBrand`对象写入`pmsBrandDto`中

#### 获取请求路径中的参数

`http://localhost:8080/springmvc/hello/101?param1=10&param2=20`

```java
@RequestMapping("/hello/{id}")
    public String getDetails(@PathVariable(value="id") String id,
    @RequestParam(value="param1", required=true) String param1,
    @RequestParam(value="param2", required=false) String param2){
.......
}
```

`@PathVariable`

* 作用：获取请求路径中的动态参数
* `getDetails`方法中，使用`@PathVariable("id") String id`来获取`/hello/{id}`中的`id`变量

`@RequestParam`

* 作用：获取请求路径中的参数
* 使用类似于 key-value 的方式来获取参数

**@RequestParam参数加与不加的区别**

* 加了此注解，就必须有参数（required=false 之后可以不带参数）
* 不加此注解，有没有参数都可以（这么看来，这个注解没啥用）

`@PathParam`

- 这个注解是和spring的`pathVariable`是一样的，也是基于模板的，但是这个是jboss包下面的一个实现，上面的是spring的一个实现，都要导包

`@QueryParam` 

- @QueryParam 是 JAX-RS 本来就提供的，和Spring的`RequestParam`作用一致

## SpingCloud

### SpringCloud 简介

核心特性：

* 服务注册与发现
* 负载均衡
* 服务之间调用
* 容错、服务降级、断路器
* 消息总线
* 分布式配置中心
* 链路器

### Eureka

Netflix 提供的一款服务注册中心，基于 **REST** 来实现服务的注册与管理

Eureka 组成：

* 服务端：注册中心，用来接收其他服务的注册
* 客户端：用来注册，并可以实现负载均衡
  * Eureka Provider：服务提供者
  * Eureka Consumer：服务消费者

Eureka 搭建

* 添加依赖
* 在启动类添加注解 `@EnableEurekaServer`
* 在`application.properties`中添加基本的配置信息

Eureka集群

* 启动多个 Eureka 实例，多个实例之间互相注册，互相同步数据

#### Eureka工作细节

Eureka Server 主要对外提供三个功能

* 服务注册：把所有的服务都注册到 Eureka Server 上面来
* 提供注册表：注册表是所有注册上来服务的列表。Eureka Client 在调用服务时，需要获取注册表。一般来说，注册表会缓存下来，如果缓存失效，就会获取最新的注册表
* 同步状态：Eureka Client 通过注册、心跳等机制，和 Eureka Server 同步当前的客户端状态

Eureka Client：会自动拉取、更新、以及缓存Eureka Server中的信息

* 服务注册：服务提供者将自己注册到服务中心。需要提供一些元数据信息，比如 IP地址、端口等等
* 服务续约：注册成功之后，Eureka Client 每隔30s就要向Eureka Server发送一条心跳信息，告诉它自己还在运行；如果 Eureka Server连续90s没有收到Eureka Client的续约消息，就会认为Client掉线，会将此Client从当前的服务注册表中剔除
* 服务下线：Eureka Client 下线时，会主动发送一条消息，告诉 Eureka Server，我下线了
* 获取注册表信息：Eureka Client 会从 Eureka Server 上获取服务的注册表信息，并将其缓存在本地。在调用远程服务时，会从注册表中查找ip、端口等信息。Eureka Client 上缓存的服务注册表信息定期更新(30s)。

#### 服务注册与消费

##### 服务注册（provider）

* 新建 SpringBoot 项目，选择 Eureka Discovery Client 和 Spring Web 依赖
* 在 `application.properties` 中配置项目的注册地址
* 写 服务接口，用 RestFul 风格的 api 接口进行调用

##### 服务消费（consumer）

* 新建 SpringBoot 项目，选择 Eureka Discovery Client 和 Spring Web 依赖

* 在 `application.properties` 中配置项目的注册地址

* 在Consumer中调用provider信息

  * 直接调用：调用写死，不会经过 Eureka

    ```java
    @GetMapping("/hello1")
    public String hello1(){
        HttpURLConnection con = null;
        try {
            URL url = new URL("http://localhost:1113/hello");
            con = (HttpURLConnection) url.openConnection();
            if (con.getResponseCode()==200){
                BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream()));
                String s = br.readLine();
                br.close();
                return s;
            }
        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return "error";
    }
    ```

  * 利用 Eureka Client 提供的 DiscoveryClient 工具，利用这个工具，可以从Eureka Server上查询到服务的详细信息

    ```
    @Autowired
    DiscoveryClient discoveryClient;
    //实现负载均衡
    int count = 0;
    @GetMapping("/hello3")
    public String hello3(){
        //要调用的服务的名字，查询到的服务列表是个集合
        List<ServiceInstance> list = discoveryClient.getInstances("provider");
        //做一个简单的线性负载
        ServiceInstance instance = list.get((count++)%list.size());
        String host = instance.getHost();
        int port = instance.getPort();
        HttpURLConnection con = null;
        StringBuffer sb = new StringBuffer();
        sb.append("http://")
                .append(host)
                .append(":")
                .append(port)
                .append("/hello");
        try {
            URL url = new URL(sb.toString());
            con = (HttpURLConnection) url.openConnection();
            if (con.getResponseCode()==200){
                BufferedReader br = new BufferedReader(new InputStreamReader(con.getInputStream()));
                String s = br.readLine();
                br.close();
                return s;
            }
        } catch (MalformedURLException e) {
            e.printStackTrace();
        } catch (IOException e) {
            e.printStackTrace();
        }
        return "error";
    }
    ```

##### 服务消费的升级改造

* Http 调用

  使用 RestTemplate 来实现

  * 首先在当前实例中提供一个 RestTemplate 实例

    ```java
    @Bean
    RestTemplate restTemplateOne(){
        return new RestTemplate();
    }
    ```

  * 在Http调用时，不再使用 HttpUrlConnection，而是直接使用 RestTemplate

    ```java
    @Autowired
    @Qualifier("restTemplateOne")
    RestTemplate restTemplateOne;
    @GetMapping("/hello2")
    public String hello2(){
        //要调用的服务的名字，查询到的服务列表是个集合
        List<ServiceInstance> list = discoveryClient.getInstances("provider");
        ServiceInstance instance = list.get(0);
        String host = instance.getHost();
        int port = instance.getPort();
        HttpURLConnection con = null;
        StringBuffer sb = new StringBuffer();
        sb.append("http://")
                .append(host)
                .append(":")
                .append(port)
                .append("/hello");
        //用restTemplate一行代码实现 htp t调用
        String s = restTemplateOne.getForObject(sb.toString(), String.class);
        return s;
    }
    ```

* 负载均衡：使用 Ribbon 来快速实现负载均衡

  * 给 RestTemplate 添加一个 @LoadBalanced 注解，开启负载均衡

    ```java
    @Bean
    //开启负载均衡
    @LoadBalanced
    RestTemplate restTemplate(){
        return new RestTemplate();
    }
    ```

  * 快速实现负载均衡

    ```java
    @Autowired
    @Qualifier("restTemplate")
    RestTemplate restTemplate;
    @GetMapping("/hello4")
    public String hello4(){
        return restTemplate.getForObject("http://provider/hello", String.class);
    }
    ```

#### RestTemplate

RestTemplate 提供了常见的 REST 请求方法模板，例如 GET、POST、PUT、DELETE 请求以及一些通用的请求执行方法 exchange 和 execute 方法

RestTemplate 实现了 RestOperations 接口，在 RestOperations 接口中，定义了常见的 RESTful 操作

##### GET

RestTemplate 中，关于 GET 请求，一共有两大类方法

* getForObject：返回的是服务端的具体值

* getForEntity：返回的是一个 ResponseEntity，除了包含服务端返回的具体数据外，还保留了 Http 响应头的数据

  ```java
  public void hello5(){
      String s1 = restTemplate.getForObject("http://provider/hello2?name={1}", String.class,"hg");
      System.out.println(s1);
      ResponseEntity<String> responseEntity = restTemplate.getForEntity("http://provider/hello2?name={1}", String.class, "hg");
      String body = responseEntity.getBody();
      System.out.println("body "+ body);
      HttpStatus status = responseEntity.getStatusCode();
      System.out.println("HttpStatus："+status);
      int statusCodeValue = responseEntity.getStatusCodeValue();
      System.out.println("statusCodeValue："+statusCodeValue);
      HttpHeaders headers = responseEntity.getHeaders();
      Set<String> keySet = headers.keySet();
      System.out.println("-------------header--------------");
      for (String s : keySet){
          System.out.println(s+":"+headers.get(s));
      }
  }
  ```

三个重载方法（三种不同的传参方式）

```java
@GetMapping("/hello6")
public void hello6() throws UnsupportedEncodingException {
    String s1 = restTemplate.getForObject("http://provider/hello2?name={1}", String.class, "hg");
    System.out.println(s1);
    Map<String, Object> map = new HashMap<>();
    map.put("name", "zhangsan");
    s1 = restTemplate.getForObject("http://provider/hello2?name={name}", String.class, map);
    System.out.println(s1);
    String url = "http://provider/hello2?name=" + URLEncoder.encode("张三","UTF-8");
    URI uri = URI.create(url);
    s1 = restTemplate.getForObject(uri, String.class);
    System.out.println(s1);
}
```

##### POST

因为 POST 请求可能需要传递JSON，所以我们要创建一个普遍的 Maven 项目作为 commons 模块，这个模块被 provider 和 consumer 共同引用，这样可以方便的传递 JSON

在 provider 中，提供两个 post 接口

```java
//key-value 形式传参
@PostMapping("/user1")
public User addUser1(User user){
    return user;
}

//JSON形式传参
@Override
public User addUser2(@RequestBody User user){
    return user;
}
```

post 和 前面的 get 十分相像，只是多了一个 postForLocation 方法

```java
@GetMapping("/hello7")
public void hello7(){
    MultiValueMap<String, Object> map = new LinkedMultiValueMap<>();
    map.add("username","hg");
    map.add("password","123");
    map.add("id", 99);
    // 使用 key-value 传参数，主要看第二个参数是 MultiValueMap 还是 普通的对象
    User user = restTemplate.postForObject("http://provider/user1",map, User.class);
    System.out.println(user.toString());

    user.setId(98);
    // 使用 JSON 传参数
    user = restTemplate.postForObject("http://provider/user2", user, User.class);
    System.out.println(user.toString());
}
```

**postForLocation**

提供一个用户注册接口

```java
@Controller
public class RegisterController {
    @PostMapping("/register")
    public String register(User user){
        System.out.println("注册请求");
        return "redirect:http://provider/loginPage?username="+user.getUsername();
    }

    @GetMapping("/loginPage")
    @ResponseBody
    public String loginPage(String username){
        return "login page : "+username;
    }
}
```

重定向的地址要写 绝对路径，不要写相对路径，否则在 consumer 中调用时会出问题

```java
@GetMapping("/hello8")
public void hello8(){
    MultiValueMap<String, Object> map = new LinkedMultiValueMap<>();
    map.add("username","hg");
    map.add("password","123");
    map.add("id", 99);
    // postForLocation 返回值是 URI，是重定向的地址（也有重定向的参数），可以使用URI发送新的请求
    URI uri = restTemplate.postForLocation("http://provider/register",map);
    System.out.println(">>>>>>>uri>>>>>>>  "+uri);
    String s = restTemplate.getForObject(uri, String.class);
    System.out.println(s);
}
```

##### PUT

put 和 post 比较像，也是两种类型的参数，key/value 形式以及 JSON 形式

##### DELETE

delete 可以使用 key/value 形式 或者 PathVariable

### Consul

Consul 是 HashiCorp 公司推出的开源产品，是 注册中心的 备选方案，还有一个是 Zookeeper

* 服务发现
* 服务隔离
* 服务配置

Consul 使用 Go 开发，在 linux 安装好就行。

项目建立和 Eureka 类似，更改一下依赖就可以。

### Hystrix

断路器：服务降级、请求命令、异常处理、请求缓存、请求合并

#### 基本使用

* 新建SpringBoot项目，添加依赖  `Spring Web、Eureka Client、Hystrix`

* 启动类添加注解 `@EnableCircuitBreaker`，也可以使用 `SpringCloudApplication` 代替

* Hystrix 接口配置

  ```
  @Service
  public class HelloService {
      @Autowired
      RestTemplate restTemplate;
      /*
      * 发起远程调用，调用provider中的hello接口
      * 但是这个调用可能会失败
      * 在方法上添加 @HystrixCommand 注解，配置 fallbackMethod 属性
      * 这个属性表示该方法调用失败时的替代方法
      */
      @HystrixCommand(fallbackMethod = "error")
      public String hello(){
          return restTemplate.getForObject("http://provider/hello", String.class);
      }
      
      //这个方法名要和 fallbackMethod ，方法返回值和对应方法也要一致
      public String error(){
          return "error";
      }
  }
  ```

#### 异常处理

#### 请求缓存

#### 请求合并

### Resilience4j

断路器

限流：RateLimter（和之前的断路器比较像）



基于信号量的隔离

缓存

限时

请求重试

### Zuul

服务网关：Zuul 和 Gateway

Zuul：权限控制、监控、动态路由、负载均衡



### RPC

rpc 主要解决两个问题

* 分布式系统中，服务之间的调用问题
* 远程调用时，要能够像本地调用一样方便，让调用者感知不到远程调用的逻辑

## Session

### 服务器重启session会失效吗

- 如果服务器不支持持久化，在服务器关闭时，会触发 `session destory` 事件
- 如果服务器支持持久化，在服务器关闭时，不会触发销毁事件，而是把每个Session内容写入文件中。当服务器再次启动时，会读取该文件，验证session是否timeout。

# 中间件

## 消息队列

消息队列可以看作是存放消息的容器，当我们需要消息的时候，可以取出消息供自己使用。

消息队列是分布式系统中的重要组件，使用消息队列是为了通过异步处理来提高系统的性能和削峰、降低系统耦合性。

### 为什么使用消息队列

- 解耦

  - 消息队列使用发布-订阅模式工作，消息发送者（生产者）发布消息，一个或多个消息接收者（消费者）订阅消息。消息发送者和消息接收者之间没有直接耦合。
  - 为了避免消息队列服务器宕机造成消息丢失，会将成功发送到消息队列的消息存储在消息生产者服务器上，等到消息真正被消费者服务器处理后才删除消息。在消息队列服务器宕机后，生产者服务器会选择分布式消息队列服务器集群中的其他服务器发布消息。

- 通过异步处理提高系统性能（减少响应所需时间）

  - A接收到的请求，需要在本地写库，也需要在BCD三个系统写库。如果不进行异步处理，一个操作的响应时间就是A+B+C+D，响应会十分缓慢。如果进行了异步操作，A只需要在本地写库之后把数据发到消息队列即可，耗时 A写库+A写消息队列

- 削峰

  - 在不使用消息队列服务器的时候，用户的请求数据直接写入数据库，在高并发的情况下，数据库压力剧增，会使响应速度变慢。在使用消息队列之后，用户的请求数据写入消息队列之后立即返回，再由消息队列的消费者进程从消息队列中获取数据，异步的写入数据库。由于消息队列服务器的处理速度快于数据库，所以响应速度会得到大幅度的改善。
  - 通过异步处理，将短时间高并发产生的事务消息存储在消息队列中，来削平高峰期的并发事务。

### 消息队列带来的一些问题

- 系统可用性降低
- 系统复杂性提高：消息重复消费、消息丢失
- 一致性问题

### 各种消息队列的比较

- ActiveMQ：性能较差，版本迭代很慢。主从架构
- RabbitMQ：吞吐量低于Kafka和RocketMQ，但是它基于erlang开发，所以并发能力很强，性能极其好，延时很低，能达到微秒级。如果业务场景对并发量的要求不是太高（十万级、百万级），RabbitMQ是首选。主从架构
- RocketMQ：阿里出品，Java系开源项目。分布式架构
- kafka：提供较少的核心功能，但是提供超高的吞吐量，ms级的延迟，极高的可用性以及可靠性，并且分布式可以任意扩展。kafka的劣势就是可能造成消息的重复消费，对数据的准确性会造成轻微的影响。

### 路由交换机的几种类型

`Exchange` ：消息交换机，它指定消息按照什么规则，路由到哪个队列

- Direct Exchange：直接匹配，通过Exchange名称+RoutingKey来发送与接受消息
- Fanout Exchange：广播订阅，向所有的消息者发布消息，但是只有消费者将队列绑定到该路由器才能收到消息，忽略RoutingKey
- Topic Exchange：主题匹配订阅,这里的主题指的是RoutingKey,RoutingKey可以采用通配符,如:*或#，RoutingKey命名采用.来分隔多个词,只有消息这将队列绑定到该路由器且指定RoutingKey符合匹配规则时才能收到消息
- Headers Exchange：消息头订阅,消息发布前,为消息定义一个或多个键值对的消息头,然后消费者接收消息同时需要定义类似的键值对请求头:(如:x-mactch=all或者x_match=any)，只有请求头与消息头匹配,才能接收消息,忽略RoutingKey

## 消息队列常见问题

### 如何保证高可用

RabbitMQ有三种模式：单机模式、普通集群模式、镜像集群模式

镜像集群才是真正的高可用

#### 普通集群模式

在多台机器上启动多个rabbitmq实例，但是你创建的queue，只会存放到一个rabbitmq实例上，其他的实例都只是同步queue的元数据。当进行消费的时候，如果消费者连接到的是另外一个实例，那么这个实例会从queue所在的实例拉取数据过来。

- 如果消费者每次随机连接一个实例，就会有数据拉取的开销
- 如果消费者每次固定连接queue所在的实例，那么就会有单实例性能瓶颈

如果存放queue的实例宕机了，那么就无法拉取消息了。

如果开启了消息持久化，也要等到节点恢复了才能继续读取消息。

**普通集群不是保证高可用的，只是为了增加吞吐量** 

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1102741/1594794619593-9084a960-61ff-4cde-96b3-a9116165345b.png)

#### 镜像集群

和普通集群的区别是，创建的queue无论是元数据还是queue里面的消息，都会存储在多个实例上。

每次写消息到queue时，都会自动把消息和多个实例上的queue进行消息同步

好处：某个实例宕机了，别的机器还可以用，服务还可以继续

坏处：性能开销太大，同步所有机器会造成网络压力变大；扩展性差，没有办法线性性扩展，因为每台机器都要包含queue的所有消息

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1102741/1594795154932-815cdc6b-98ef-40e6-a5fd-4efaec09eaac.png)

#### kafka高可用性

kafka的基本架构：

- kafka由多个broker组成，每个broker都是一个节点
- 创建一个topic，这个topic可以划分为多个partition
- 每个partition可以存放在不同的broker上，每个partition就存放一部分数据

kafka高可用性：每个节点都有副本，leader挂掉之后，副本可以竞争成为leader。

![image.png](https://cdn.nlark.com/yuque/0/2020/png/1102741/1594795635545-bb63b7f8-5fbb-49cf-a40e-e2f839436cc2.png)

### 如何保证不被重复消费

为什么会有重复消费？

以kafka为例，每个消息写进去都会有 `offset` ，代表它的序号，然后消费者消费之后，每隔一段时间都要把自己消费过的offset交代一下，代表我已经消费过这个信息了，下次重启的时候，从上次消费过的开始。

如果系统重启的时候， `offset`还没有提交，那么下次消费的时候，就会有些消息会被重复消费。

**幂等性**：一个数据或者一个请求重复多次，要保证对应的数据是不会出错的

如何保证不被重复消费（结合业务场景）？

- 如果数据要写库，现根据主键查一下，要是数据已经有了，就别插入了，update一下
- 如果是写redis，redis的set具有天然幂等性
- 让生产者发送数据的时候，里面加一个全局的唯一id，类似订单id，然后消费到了之后，先根据这个id去（比如redis里）查一下消息是否被消费过。如果没有被消费过，就对消息进行处理，然后写redis；如果消费过，就不用做任何处理。

### 如何保证可靠性传输

#### rabbitmq

- 生产者弄丢了数据（发送数据到rabbitmq时，信息丢失）

  - 可以采用rabbitmq的事务功能，生产者发送数据之前开启rabbitmq的事务，然后发送消息。

    - 如果消息没有成功被rabbitmq接收到，那么生产者就会产生异常报错，回滚事务。
    - 如果收到消息，就提交事务。
    - 缺点：吞吐量会下降，因为太耗费性能

  - 在生产者设置那里开启 `confirm` 模式

    - 每次写的消息都会分配一个唯一的id，然后写入rabbit中，rabbit会回传一个ack消息，告诉接收成功
    - 如果没能处理这个消息，就会回调一个 nack 接口，搞素消息接受失败，可以重试。
    - 可以结合这个机制，自己在内存里维护每个消息的id状态，如果超过一定时间还没收到回调，就重试

  - 两者的不同之处在于，事务机制是同步的，提交事务的时候会阻塞；confirm 机制是异步的，发送之后可以继续发送别的消息，rabbitmq接收之后会异步回调一个接口通知你消息收到了

- rabbitmq弄丢了数据

  - 开启rabbitmq的持久化，消息写入之后持久化到磁盘。即使rabbitmq自己挂掉，恢复之后也会自动读取之前存储的数据，一般不会丢失。（除非在rabbitmq持久化之前挂掉，可能导致少量数据丢失）
  - 设置持久化的步骤

    - 创建queue的时候将其设置为持久化，这样可以保证rabbitmq持久化queue的元数据，但是不会持久化queue里的数据
    - 发送消息的时候将消息的 `deliveryMode` 设置为2，这就是将消息设置为持久化的

  - 持久化可以和生产者的 `confirm` 机制结合起来，只有在持久化到磁盘之后，才通知生产者ack。这样rabbitmq在持久化到磁盘之前挂掉，也会重发数据。

- 消费端丢失数据（刚消费到，还未处理，进程挂掉）

  - 使用rabbitmq提供的ack机制，关闭rabbitmq的自动ack，可以通过一个api来调用，在自己的代码确保处理完之后，再进行ack。这样的话，没有处理的消息就会分给其他的消费者，不会丢失。

#### kafka

- 消费端弄丢数据（消费者再处理之前旧提交了offset，然后挂掉）

  - 关闭自动提交offset，再处理完之后手动提交offset。这样可能会导致重复消费，需要自己保证幂等性

- kafka弄丢数据（其他follower再同步数据的时候，leader挂掉）

  - 给topic设置 `replication.factor` 参数：这个值必须大于1，要求每个partition至少拥有两个副本
  - kafka服务端设置 `min.insync.replicas` 参数：这个值必须大于1，要求一个leader要感知到至少还有一个follower跟自己保持联系
  - producer端设置acks=all：要求每条数据必须写入所有replica之后，才能被认为写入成功
  - producer端设置retires=MAX（很大很大的值，无限重试）：要求一旦写入失败，就无限重试

- 生产者端在上述设置（acks=all）之后，不会丢失数据

### 如何保证消息顺序

#### rabbitmq保证消息的顺序性

- 拆分多个queue，每个queue对应一个customer
- 一个queue 对应一个customer，然后在这个customer内部用内存队列做排队，然后分发给底层不同的worker来处理

#### kafka保证消息的顺序性

kafka写入partion时指定一个key，例如订单id，那么消费者从partion中取出数据时肯定是有序的。

当开启多个线程的时候可能导致数据不一致，这时可以使用内存队列，将相同的hash过的数据放到一个内存队列中，这样就能保证一条线程对应一个内存队列的数据，在写入数据库的时候是有序的，从而可以开启多条线程对应多个内存队列。

# JVM

## Java内存区域（运行时数据区）

<img src="https://cdn.nlark.com/yuque/0/2020/png/1102741/1584769692763-26c76ea2-2a37-45c0-9513-0e2174307c9e.png?x-oss-process=image%2Fresize%2Cw_868" alt="image.png" style="zoom:50%;" />

### 程序计数器

线程私有，可以看作当前线程所执行的字节码的行号指示器

**作用** 

- 字节码解释器通过改变计数器的值来依次读取指令，从而实现代码的流程控制。（如顺序、选择、循环等）
- 在多线程的情况下，程序计数器用来记录当前线程执行的位置，从而当线程被切换回来的时候，就能知道该线程上次运行到哪里了

### 虚拟机栈

- 线程私有，生命周期和线程相同，描述的是Java方法执行的内存模型
- 方法的运行，对应着栈帧的入栈与出栈
- 虚拟机栈由栈帧组成，每个栈帧中都拥有：局部变量表、操作数栈、动态链接、方法出入口信息
- 局部变量表存放的是：编译期可知的 各种基本数据类型、对象引用(reference)

**异常** 

- StackOverFlowError：Java虚拟机栈的内存不允许动态扩展，且线程请求的栈深度达到虚拟机栈的最大深度
- OutOfMemoryError：虚拟机栈的内存允许扩展，但是线程请求栈时内存用完了，无法再动态扩展

### 本地方法栈

- 线程私有
- 虚拟机使用到的 Native 方法服务
- 栈帧和异常都和上一个类似

### 堆

- 线程共享
- 存放对象实例，几乎所有的对象实例和数组都在堆上分配

### 方法区

- 线程共享
- 存储已经被虚拟机加载的 类信息、常量、静态变量、即时编译器编译后的代码数据

### 运行时常量池

- 是方法区的一部分
- 用于存放 各种字面量和符号引用，类加载后进入方法区的运行时常量池中存放
- JDK1.7之后，字符串常量池从方法区中移动到了堆中
- 废除永久代之后，运行时常量池移动到了元空间

​         ![image.png](https://cdn.nlark.com/yuque/0/2020/png/1102741/1592707241466-e971aa9b-5286-4806-91b2-354ebf851512.png)

### 问题

#### 方法区和永久代的关系

- Java虚拟机规范中，规定了方法区有这么个概念和它的作用，但是没有规定如何去实现它
- 方法区和永久代的关系像是Java中接口和类的关系，类实现的接口
- 永久代就是 HotSpot 虚拟机对方法区的是实现方式

#### 为什么将永久代替换为元空间

* 因为永久代内存经常不够用或者发生内存泄漏
* 元空间和永久代类似，两者最大的区别在于
  * 永久代有一个JVM设置的固定大小上限，无法进行调整
  * 元空间使用的是直接内存，受本机可用内存限制，溢出的几率大大减少

#### 堆和栈的区别

栈内存：栈是一整片内存区域，存储的都是局部变量（凡是定义在方法中的都是局部变量）。需要先加载函数才能进行局部变量的定义，所以方法先进栈，再定义变量，变量有自己的作用域，一旦离开作用域，就被会释放。

堆内存：存储的是数组和对象(数组也是对象)。凡是通过 new 建立的都是在堆中，堆上存放的都是 实体。堆上的实体不会被释放，只会被Java垃圾回收机制不定时的回收。

`int[] arr = new int[3]`

* 主函数进栈，定义变量 arr，接下来对 arr 赋值
* 在堆中开辟一个空间，分配内存

栈与堆的区别

* 栈上存储的是局部变量，堆上存储的是实体
* 栈内存的更新速度要快于堆内存，因为局部变量的生命周期比较短
* 栈上的变量生命周期以结束就会被释放；堆上的实体会被垃圾回收机制不定时的回收

#### 堆溢出和栈溢出

栈溢出：方法执行时，创建的栈帧请求的深度，超过了栈能给予的最大深度

* 方法的递归调用

解决方法：`-Xss` 调整 JVM 栈的大小



堆溢出：没有空间分配新的对象

解决方法：

* `-Xmx 3550m`：设置 JVM 最大可用内存
* `-Xms 3550m`：设置 JVM 促使内存，避免每次垃圾回收完成后，JVM 重新分配内存
* `-Xmn 2g`：设置年轻代为 2G。JVM内存大小=年轻代+老年代+持久代(一般为64m)

## 对象创建相关问题

### 对象创建全过程

* 首先检查 new 指令的参数是否能在常量池中定位到一个类的符号引用。并且检查这个类是否被加载、解析、初始化过。如果没有，就执行相应的过程
* 虚拟机为新生对象分配内存（分配内存大小在类加载完成后便完全确定）
  * 在 Java 堆上的内存分配方式
    * 指针碰撞：Java 堆上的内存规整，用过的在一边，没用过的在一边，依靠指针移动分配内存。
    * 空闲列表：Java 堆上的内存不规整，维护一个列表来记录可用的内存块
    * Java 堆是否规整由垃圾收集器是否带有压缩整理功能决定。
      * Serical、ParNew：指针碰撞
      * CMS：空闲列表
  * 对象创建是否频繁（并发问题）
    * 对分配内存空间的动作进行同步处理：CAS+失败重试 保证更新操作的原子性
    * TLAB（本地线程分配缓冲）：每个线程在Java堆中预先分配一块小内存
* 初始化零值：将分配到的内存空间都初始化零值（不包括对象头），保证了对象的实例字段在Java代码可以不赋初值就直接使用
* 对象头信息：虚拟机对对象进行必要的设置，这些信息都放在对象头中，主要包括：对象是哪个类的实例、如何让找到类的元数据信息、对象的Hash码、对象的GC分代年龄等。
* 执行 init 方法：上述步骤执行完之后，从虚拟机的角度看，一个新的对象已经产生。但是在Java程序的视角来看，init 方法还未执行，所有的字段都还是零值。执行 new 指令之后，需要接着执行 init 方法，把对象按着程序员的意愿进行初始化

### 对象内存布局

对象在内存中的存储布局可以分为三块区域

* 对象头

  * 自身运行时数据 MarkWord：HashCode、GC分代年龄、锁状态标志、线程持有的锁、偏向线程ID等

    ![img](https://img-blog.csdn.net/20151217151455512?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQv/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/Center)

  * 类型指针：指向它的类元数据的指针（Java数组对象头还有一块用于记录数组的长度）

* 实例数据：各种类型的字段内容（父类继承、子类定义。父类定义的变量会出现在子类之前）

* 对齐填充：对象的大小必须是 8字节的 整数倍

`Object o = new Object()`

`o` 占有多少大小：16个字节

* 对象头：
  * MarkWord：64位，8个字节
  * 类型指针：64位，开启压缩之后32位，4个字节
* 实例数据：这里没有，为 0 个字节。（如果有的话，大小如下）
  * byte：1字节；short：2字节；int：4字节；long：8字节；
  * float：4字节；double：8字节
  * char：两个字节
  * boolean：在 JVM 中，boolean 被当作 int 变量处理：4个字节；boolean 数组当作 byte 数组处理，1个字节
* 对齐填充：总数要为 8 的倍数，一共是 16

### 对象访问定位

* 句柄访问：Java堆中划出一块内存作为句柄池

  <img src="https://cdn.nlark.com/yuque/0/2020/png/1102741/1584770006551-7c44c5fe-feeb-46e8-a654-993520fdfe00.png?x-oss-process=image%2Fresize%2Cw_876" alt="image.png" style="zoom:50%;" />

* 直接指针：Java堆中要考虑如何放置访问的类型数据相关信息

  <img src="https://cdn.nlark.com/yuque/0/2020/png/1102741/1584770028911-ec16e4a9-b63d-491f-aa4d-6ae96a8dfd3f.png?x-oss-process=image%2Fresize%2Cw_880" alt="image.png" style="zoom:50%;" />

### 对象内存分配

<img src="https://cdn.nlark.com/yuque/0/2020/png/1102741/1584771472063-0ba138f7-d680-456b-878a-f97a000ab407.png?x-oss-process=image%2Fresize%2Cw_880" alt="image.png" style="zoom:50%;" />

对象的分配主要在 新生代的Eden区，如果启用了本地线程分配缓冲，将会按线程优先在TLAB上分配

* 对象优先在 Eden 分配：大多数情况下，对象在新生代 Eden 区中分配，当 Eden 中没有足够的空间时，虚拟机进行一次 Minor GC
* 大对象直接进入老年代：大对象是指 需要大量连续内存空间 的Java对象（典型的是 很长的数组以及字符串）
* 长期存活对象进入老年代：如果对象在 Eden 区出生，且经过一次 Minor GC 之后依然存活，就会被移动到 Survivor 控件，年龄设置为1，对象在 Survivor 中，每熬过一次 GC，年龄加1，到一定年龄（默认15），就会进去老年代
* 动态对象年龄绑定：虚拟机不是要求对象年龄必须达到阈值才进入老年代；当 Survivor 中相同年龄的对象占到空间的一半，大于等于此年龄的可以进去老年代
* 空间分配担保：虚拟机检查老年代的最大可用连续空间是否大于新生代所有对象总空间
  * 如果大于，那么这次Minor GC可以确保是安全的
  * 如果不是，那么虚拟机会查看HandlePromotionFailure是否允许担保失败
    * 如果允许，会检查 老年代最大可用连续空间 是否大于 历次晋升到老年代的对象的平均大小
      * 如果大于，进行一次有风险的 Minor GC
    * 如果不允许担保失败 或者  最大连续可用空间 小于 历次晋升对象的大小，那就只能进行一次 Full GC

## 垃圾回收

### 哪些对象需要回收

* 引用计数法：
  * 在对象中添加一个引用计数器，每当有一个地方引用它，计数器+1；引用失效时，计数器-1
  * 缺点：难以解决对象间的循环依赖
* 可达性分析：从 `GC Roots` 开始向下搜索，当一个对象到 `GC Roots` 没有引用链存在时，就被判定为可以回收的

可以作为**`GC Roots`**的对象

* 虚拟机栈（栈帧中的**本地变量表**）中引用的对象
* 方法区中 **类静态属性** 引用的对象
* 方法区中 **常量** 引用的对象
* 本地方法栈中 JNI（**Native方法**）引用的对象

### 回收方法区

永久代的垃圾收集 主要回收两部分内容

* 废弃的常量：没有被其他地方引用
* 无用的类
  * 该类的所有实例都被回收
  * 加载该类的 ClassLoader 也被回收
  * 该类对应的 java.long.Class 对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法

### 引用类型

* 强引用：在代码中普遍存在的引用，例如 Object obj=new Object()。只要强引用存在，垃圾收集器就永远不会回收掉被引用的对象

* 软引用：用来描述有用但非必需的对象。在系统发生内存溢出异常之前，会把这些对象列入回收范围，进行**二次回收** 。如果回收之后依旧没有足够的内存，才会抛出内存溢出异常

* 弱引用：描述非必须对象，强度比软引用还要弱。弱引用关联的对象只能生存到下一次垃圾收集之前。当垃圾收集器工作时，无论当前内存是否足够，都会回收掉只被弱引用关联的对象

* 虚引用：幽灵引用或者幻影引用；虚引用不会对对象生存周期造成任何影响，也无法通过虚引用获取对象实例为对象设置虚引用 的目的：能在这个对象被垃圾收集器回收时，收到一个系统通知

#### 虚引用

有一些 Java 对象，关联着一些 不归 JVM 管理的内存

这种对象要回收的时候，要把对应的 堆外内存 回收掉

JVM 的做法是给Java对象加一个虚引用

虚引用一旦被回收，就会被写到队列里

有一个线程监控着队列，只要队列中不为空

就说明有一个与堆外内存相关的对象被回收了

就要通过某些方法来处理堆外内存

### 垃圾收集算法

* 标记-清除算法
  * 标记：标记出需要回收的对象
  * 清除：标记完成后，统一回收被标记的对象
  * 缺点：效率不高；会产生空间碎片
* 复制算法（新生代）
  * 按照  8:1:1 来分配内存空间
  * 回收的时候，把 Eden 和 其中一个 Survivor 上活着的对象放到另一个 Survivor 上
  * 再清理 Eden 和 使用过的 Survivor
* 标记-整理算法（老年代）
  * 标记：标记出需要回收的对象
  * 整理：让存活的对象都向一端移动，然后清理掉端边界以外的内存
* 分代收集（根据对象存活周期划分内存）
  * 新生代：复制算法
  * 来年代：标记-清理/整理

### HotSpot算法实现

#### 枚举根节点

可达性分析中，可以作为 GC Roots 的节点主要在 **全局性的引用（方法区中的常量和类静态属性）** 和 **执行上下文（栈帧中的本地变量表）** 中

可达性分析对执行时间敏感：需要 stop the world

主流的 Java虚拟机 都是准确性 GC

* 不需要一个不漏地检查完所有 执行上下文 和 全局性的引用
* HotSpot中，使用一组称为 OopMap 的数据结构 来得知哪些地方存着对象引用

#### 安全点

在 OopMap 的协助下，HotSpot 可以快速且准确的完成 GC Roots 的枚举

如果每一条指令都记录这些信息，会需要大量的额外空间

所以只在特定位置（安全点 Safepoint）记录了这些信息

* 程序执行只有在到安全点时，才能暂停

* 如何在 GC 时让所有线程都到 安全点

  * 抢先式中断：不需要线程的执行代码主动去配合（不使用）

    在GC发生时，首先中断所有线程，如果发现有线程中断的地方不在安全点上，就恢复线程，让它跑到安全点

  * 主动式中断：

    不直接不线程进行操作。仅仅设置中断标志，各个线程执行时主动去轮询这个标志，发现中断标志为真时就自己中断挂起

#### 安全区域

提出原因：程序在不执行时，就无法到达安全点

典型例子：线程处于 `Sleep` 或者 `Blocked` 状态

解决方法：在一段代码片段中，引用关系不会发生变化，在这个区域（安全区域）的任意地方开始 GC 都是安全的

* 线程执行到 `Safe Region` 中时，就标识自己 已经进入安全区域
* 这段时间发起 GC 的时候，不用管标识为 `Safe Region` 状态的线程
* 当线程离开安全区时，要检查系统是否已经完成了根节点的枚举
  * 如果完成，线程继续执行
  * 如果没有，等待直到收到可以安全离开 `Safe Region` 的信号为止

### 垃圾收集器

![image-20200810180118579](C:\Users\hg\AppData\Roaming\Typora\typora-user-images\image-20200810180118579.png)

#### Serial

* 最基本，最悠久的垃圾收集器
* 单线程：在进行垃圾收集时，必须暂停其他所有的工作线程，直至收集结束
* 新生代：复制算法；
* 适合Client模式下的虚拟机：没有线程交互的开销，简单高效

#### ParNew

* Serial 的多线程版本，使用多条线程进行垃圾收集
* 除了 Serial，只有 ParNew 可以与 CMS 配合工作

#### Parallel Scavenge

* 新生代：复制算法、并行多线程收集器
* 和其他的不同之处在于：
  * CMS 等是为了 尽可能缩短垃圾收集时用户线程的停顿时间
    * 适合需要与用户交互的此程序
  * Parallel Scavenge 的目标是 达到一个可控制的吞吐量
    * 吞吐量 = 运行用户代码时间 / （垃圾收集时间+运行用户代码时间）
    * 高效利用 CPU，适合在后台运算，不需要太多交互的任务

#### Serial Old

* Serial 的老年代版本：单线程，标记整理算法
* Client 模式下给虚拟机使用

#### Parallel Old

* Parallel Scavenge 收集器的老年代版本
* 使用 多线程、标记整理算法
* 和 Parallel Scavenge 组合使用，适合注重 吞吐量以及CPU资源敏感的场合

#### CMS

* 目的：获取最短停顿时间，使用 标记-清除算法
* 运行过程（初始标记、重新标记 需要 stop the world）
  * 初始标记：标记 GC Roots 能直接关联到的对象
  * 并发标记：GC Roots Tracing 的过程（耗时较长）
  * 重新标记：修正并发标记期间，因为用户程序继续运行，而导致标记产生变动的那一部分对象的标记记录
  * 并发清除：耗时较长
* 优点：并发收集、低停顿
* 缺点
  * 对 CPU 资源非常敏感：默认启动的回收线程数是 （CPU+3）/4，当CPU不足 4 个的时候，对用户程序影响会比较大。
  * 无法处理浮动垃圾，可能出现 `Concurrent Mode Failure`
    * 并发清除阶段会由于 用户线程的运行 不断的产生新的垃圾
    * CMS 收集器不能等到老年代要满的时候再收集，因为需要给用户线程留一部分空间。这个大小可以设置，当预留的空间无法满足程序需要时，就会出现`Concurrent Mode Failure`，这时临时启动 Serial Old 来进行垃圾收集
  * 标记-清除算法，会产生大量空间碎片：当因为空间碎片过多，而无法分配大对象时，会提前触发一次 Full GC

#### G1 收集器

G1 收集器的运作过程

* 初始标记：标记 GC Roots 能直接关联到的对象，需要 stop the world
* 并发标记：可达性分析，耗时较长；可并发执行
* 最终标记：修正并发标记期间发生变化的标记记录，记录最终合并到 Remember Set 中；需要停顿线程，但是可以并行执行
* 筛选回收：按照 Region 的回收价值和成本进行排序，根据用户所期望的 GC 停顿时间 来指定 回收计划

G1 是面向服务端应用的 垃圾收集器，G1 的特点如下

* 并发与并行
  * G1 能充分利用 多CPU、多核 环境下的硬件优势，使用多个 CPU 或者 核心 来缩短 stop the world 停顿的时间
  * 部分其他收集器原本需要停顿的 Java 线程执行的 GC 动作，G1 收集器 仍然可以通过并发的方式让 Java 程序继续执行
* 分代收集
  * 不需要其他收集器配合，独立管理整个 GC 堆
  * 能够采用不同的方式去处理新创建的对象 和 已经存活了一段时间、熬过了多次 GC 的旧对象，已达到更好的收集效果
* 空间整合
  * G1 从整体上来看，是基于 标记—整理 算法实现
  * 从局部来看，是基于 复制 算法实现的
* 可预测停顿：建立可预测的 停顿时间模型

G1 收集器 Java堆 的内存布局

* 将整个 Java 堆划分成多个大小相等的独立区域（Region）
* 虽然保留了 新生代和老年代的概念，但它们已经不是 物理隔离 的了，它们都是一部分 Region 的集合

建立预测时间模型

* G1 跟踪 每个 Region 里面的 垃圾堆积的价值大小，在后台维护一个优先列表，每次根据允许的收集时间，优先回收价值最大的 Region

Remember Set

* G1 的每个 Region 都对应一个 Remember Set
* 虚拟机发现程序在对 Reference 类型的数据进行写操作时，会产生一个 Write Barrier 暂时中断写操作，检查 Reference 引用的对象是否存在于不同的 Region 之中
  * 如果是，便把相关的引用信息 记录到 被引用对象所属的 Region 的 Remember Set 之中
* 当进行内存回收时，在 GC 根节点的枚举范围中 加入 Remember Set 既可以保证 不对全堆扫描，也不会有遗漏

## 双亲委派模型

类加载器

* 启动类加载器
* 扩展类加载器
* 应用程序类加载器

双亲委派模型

* 在类加载的时候，首先会判断此类是否被加载过。已经给加载过的类会直接返回，否则才尝试加载
* 加载时会把请求委托给父类加载器，因此所有的加载请求最终都会传递到  启动类加载器
* 当父类加载器无法处理时，才会由自己来处理

### 好处

- 保证了Java程序的稳定运行，可以避免类的重复加载。（JVM区分不同类的方式不仅仅是根据类名，相同的类文件被不同的类加载器加载，产生的也是两个不同的类）
- 保证了Java核心的API不会被更改

## Java 内存模型与线程

### 原子性、可见性、有序性

* 原子性
  * 基本数据类型的读写时具备原子性的（long double 例外）
  * `lock unlock` 保障更大范围的原子性
    * 字节码层面是 `monitorenter monitorexit`
    * Java 代码层面 `sychronized`
  * 处理器如何实现 原子性
    * 锁总线：`LOCK #`
    * 缓存锁定：
* 可见性：一个线程修改了变量的值，其他线程立即可见
  * volatile：保证新值可以立即从 工作内存 刷新回 主内存
  * synchronized：对一个变量执行 unlock 命令时，必须先把此变量同步回主内存
  * final：final 修饰的字段在构造器中 一旦初始化完成，并且构造器没有把 this 引用传递出去，那在其它线程中就能看到 final 字段的值
* 有序性：在本线程内观察，所有操作都是有序的（线程内串行）；在一个线程中观察另一个线程，所有操作都是无序的（指令重排序）
  * volatile：禁止指令重排序（**不能实现并发安全**）
  * synchronized：一个变量在同一时刻，只允许一条线程对其进行 lock 操作

### volatile

#### 线程可见性

缓存一致性协议 MESI：cpu缓存的数据一致性，是按照 缓存行（64个字节）来进行的

并发包利用此特性，进行缓存行填充，可以提升性能

![image-20200803181344099](C:\Users\hg\AppData\Roaming\Typora\typora-user-images\image-20200803181344099.png)

系统底层如何实现数据一致性

* MESI 如果可以解决，就用 MESI
* 如果不能，就锁住总线

#### 禁止指令重排序

* Java代码：volatile

* 字节码：变量加上了 ACC_VOLATILE 标识

* JVM层面：内存屏障，屏障两边的指令**不可以重排序**，保障有序

  volatile 实现细节：在volatile读写操作 前后加屏障

  ![image-20200804082100698](C:\Users\hg\AppData\Roaming\Typora\typora-user-images\image-20200804082100698.png)

* 底层实现：lock 操作 锁住总线



**基于 volatile 的变量，在并发环境下不是安全的**

* 虽然 volatile 变量不存在一致性问题
* 但是 Java 里面的运算是 **非原子** 操作



### Synchronized

实现过程

1. java代码：synchronized

2. class文件：使用到了监视器。monitorenter、moniterexit，分别指向 同步代码块 开始和结束的位置

   线程试图获取锁，也就是获取 monitor（监视器对象存在于每个Java对象的对象头中，这也就是为什么每个Java对象都可以作为锁的原因）

3. 执行过程中自动升级

4. 汇编层面：lock cmpxchg

### CAS

![image-20200803144959409](C:\Users\hg\AppData\Roaming\Typora\typora-user-images\image-20200803144959409.png)

CAS的步骤：

1. 读取当前值，保存为 E
2. 对读到的值进行计算，得到结果 V
3. 再次读取当前值 N，比较 E==N?
   * 如果相等：就把计算结果 V ，赋给当前值
     * ABA问题：通过添加版本号来解决
   * 如果不等：说明中间被修改了，再来一次

`lock cmpxchg`：CAS操作对应的汇编指令

* 指令不是原子性
* lock 的意思是，在执行后面那个指令（也就是进行赋值）的时候，不会被其他CPU打断

### 线程安全的实现方法

#### 互斥同步（阻塞同步）

互斥是手段：临界区、互斥量、信号量

同步是目的：多个线程并发访问共享数据时，保证共享数据在同一时刻，只能被一个线程使用

* 最常见的是 synchronized 关键字：

  * 编译后在同步块前后形成 `monitorenter monitorexit` 两个字节码指令
  * synchronized 通过参数来指定锁定和解锁的对象。
    * 如果指定了对象参数，就是这个对象的 reference
    * 如果没有指定
      * 修饰的实例方法：锁定对象实例
      * 修饰的静态方法：锁定 Class 对象
  * 需要注意的点
    * synchronized 是可重入的
    * 同步块 在已进入的线程执行完成之前，会阻塞后面 其他线程的 进入

* 也可以使用 JUC 包下的 可重入锁（ReentrantLock）来实现

  可重入锁 与 synchronized 相比的高级功能

  * 等待可中断
  * 公平锁
  * 绑定多个条件

#### 非阻塞同步

* 互斥同步：线程阻塞和唤醒带来性能消耗，悲观策略
* 非阻塞同步：最常见 CAS，乐观策略

#### 无同步方案

* 可重入代码：可以随时停止去执行其他线程（可重入代码 —> 线程安全）

  可重入代码的特征

  * 不依赖堆上的数据 和 公共的系统资源
  * 使用的状态量都由参数中传入
  * 不调用 非可重入的方法

  判断方法

  * 返回结果可预测

* 线程本地存储：ThreadLocal

### 锁升级过程

![image-20200803144058035](C:\Users\hg\AppData\Roaming\Typora\typora-user-images\image-20200803144058035.png)

偏向锁 -> 轻量级锁：出现竞争

轻量级锁 -> 重量级锁：竞争加剧（自旋操作消耗的CPU资源过多）

#### 轻量级锁

在没有多线程竞争的前提下，减少传统的 重量级锁使用 操作系统互斥量 产生的性能消耗

* 进入同步块之前，如果同步对象没有被锁定（锁标志位 01）
* 虚拟机在当前栈帧建立一个名为锁记录（Lock Record）的空间，用来存储对象当前的 Mark Word 拷贝
* 虚拟机尝试使用 CAS 操作 将对象的 Mark Word 更新为指向 Lock Record 的指针
  * 更新成功：线程拥有该对象该锁，锁标志位变为 00
  * 更新失败：检查当前对象的 Mark Word 是否指向 当前线程的栈帧
    * 是：当前线程已经拥有了这个对象的锁，可以直接进入同步块
    * 否：两个以上的线程争用同一个锁，膨胀为重量级锁（锁标志位 10），Mark Word 存储重量级锁的指针，后面等待锁的线程 进入阻塞状态

#### 偏向锁

* 锁第一次被线程获取的时候，虚拟机把对象头中的标志位设置为 01
* 使用 CAS 操作把获得这个锁的 线程的ID 记录在对象的 Mark Word 中
  * CAS 成功：该线程以后再进入这个锁的同步块，不再进行任何同步操作
* 有另一个线程竞争：偏向模式失效

## 面试问题

### 常量池

常量：被 `final`  修饰的成员变量表示常量，值一旦给定，就无法改变

Java 中的常量池

* 静态常量池：`.class` 文件中的常量池， class 文件中的常量池不仅仅包含 字符串(数字)字面量，还包含 类、方法的信息
  * 可以理解为 class文件的 资源仓库，是占用 class 文件空间最大的数据项目之一
  * 是在编译期间被确定，并保存在 已编译的 `.class` 文件中的一些数据
    * 字面量：Java语言层面常量的概念，比如 文本字符串、声明为 final 的常量值
    * 符号引用：类和接口的全限定名、字段名称和描述符、方法名称和描述符
* 运行时常量池：jvm 虚拟机在完成类装载操作后，会将 `class` 文件中的常量池 载入到内存中，并保存在方法区中
  * 是方法区的一部分
  * 用于存放 **编译期** 生成的 **各种字面量和符号引用**，这部分内容再类加载后进入方法区的运行时常量池中存放
  * 和 `.class` 中常量池的不同之处在于，运行时常量池具有 **动态性**
  * Java 中基本数据类型的包装类，除了 `Float、Double`，剩下的几个都实现了常量池技术。对应的值在 -128~127 时，会直接使用常量池，节省内存

虚拟机运行时，需要从常量池中获取对应的符号引用，再在 **类创建时或者运行时解析并翻译到具体的内存地址**

# 数据库

## MySQL

### 基本架构（查询语句的如何执行）

Server层：

- 连接器：在登陆MySQL的时候，进行身份认证和权限登录。如果账号密码都通过，就回去权限表中查询该用户的所有权限。
- 查询缓存：在执行查询语句的时候，会先查询缓存（MySQL8.0版本之后移除，因为不太实用）。MySQL会先校验这个sql是否被执行过，以Key-Value的形式缓存在内存中，key是查询预计，value是结果集。如果key被命中，就直接返回结果；如果未命中，就会执行后续的操作，完成后把缓存结果存起来。
- 分析器：如果缓存未命中，SQL语句就会经过分析器。分析器主要分为两步，词法分析：提取关键词，比如表明、字段名、查询条件等；语法分析：判断输入的sql是否正确，是否符合MySQL的语法。
- 优化器：按照MySQL认为最优的方案去执行，比如多个索引的时候如何去选择索引，多表查询的时候如何选择关联顺序等。
- 执行器：执行语句，然后从存储引擎返回数据。首先在执行前会校验该用户有没有权限，如果没有权限，就会返回错误信息；如果有权限，就会调用执行引擎的接口，返回执行结果。

引擎层：

- 主要负责数据的存储和读取，采用可替换的插件式架构，支持InnoDB、MyISAM等多个存储引擎
- MySQL5.5版本之后，InnoDB引擎就作为默认存储引擎

### 三范式

第一范式：列不可再分

第二范式：属性完全依赖于主键

第三范式：属性不依赖于其他非主属性，属性直接依赖于主键

### 存储过程

存储过程是一组为了完成特定功能的 SQL 语句集，存储在数据库中，经过第一次编译之后不需要再次编译，用户通过指定存储过程的名字 并 给出参数（如果该存储过程带有参数）来执行它。

### 存储引擎

#### MyISAM 和 InnoDB 的区别

* 是否支持行级锁：InnoDB支持，MyISAM 只有表级锁
* 是否支持事务和崩溃后的安全恢复：InnoDB支持，MyISAM不支持
* 是否支持外键：InnoDB 支持，MyISAM 不支持
* MVCC：InnoDB 支持，MyISAM 不支持

### 事务

#### 四大特性

ACID

* 原子性：事务中操作要么全部提交成功，要么全部失败回滚
* 一致性：事务提交之前，事务中的修改不保存到数据库中
* 隔离性：一个事务在提交之前，对其他事务不可见
* 持久性：一旦事务提交，修改永久保存到数据库

#### 隔离级别

- 未提交读：事务中的修改即使没有提交，也对其他事务可见。事务可能读到其他事务未提交的信息，称为**脏读**。

- 提交读：事务从开始到提交前，所做的修改对其他事务不可见（大多数数据库默认隔离级别）

  可能执行两次相同的查询，得到不一样的结果，因为另一个事务提交了新的数据（**不可重复读**）

- 可重复读：同一事务多次读取同样的记录，结果是一致的（MySQL默认隔离级别）

  可能导致**幻读**：事务在读取某个范围的记录时，另一个事务在此范围内插入了新的事务，当前事务再次读取，会产生幻行

  InnoDB 解决幻读

  * MVCC 
  * 间隙锁

- 可串行化：强制事务串行执行，在读取的每一行数据上都会加锁

| 隔离级别 | 脏读 | 不可重复读 | 幻读 | 加锁读 |
| -------- | ---- | ---------- | ---- | ------ |
| 未提交读 | √    | √          | √    |        |
| 提交读   |      | √          | √    |        |
| 可重复读 |      |            | √    |        |
| 可串行化 |      |            |      | √      |

#### MVCC

MVCC：是行级锁的一个变种，但是在很多情况下避免了加锁操作，因此开销更低。实现了非阻塞的读操作，写操作也只需要锁定必要的行。

MVCC实现：

- 通过保存数据在某个时间点的快照来实现的。
- 这意味着一个事务无论运行多长时间，在同一个事务里能够看到数据一致的视图。
- 根据事务开始的时间不同，同时也意味着在同一个时刻不同事务看到的相同表里的数据可能是不同的。

InnoDB引擎为例：

InnoDB实现MVCC是通过在每个记录后保存两个隐藏列来实现的

​       两列一个保存行的创建时间，一个保存行的过期时间（创建时间都是系统版本号，过期时间开始为空）

开始新的事务，系统版本号会递增。事务版本号就是事务开始时刻的系统版本号。

MVCC在 可重复读 的隔离级别下的操作：

- SELECT

  - a.  InnoDB 只查找版本早于当前事务版本的数据行

    这样可以保证事务读取的行，是事务开始之前就存在的或者是事务本身插入的

  - b.  行的删除版本要么未定义，要么大于当前的事务版本号，

    这样确保事务读取的行在事务开始之前未被删除

- INSERT

​       InnoDB为新插入的每一行保存当前系统版本号作为行版本号

- DELETE

​       InnoDB为删除的每一行保存当前的版本号作为删除标志(过期时间)

- UPDATE

​       InnoDB插入一行新纪录，保存当前系统的版本号作为行版本号

​       同时保存当前系统版本号作为原来行的删除标识(过期时间)

### 索引

#### 索引基础

##### 索引创建

- 创建单列索引

  - 普通索引：最基本的索引 
  
    ```java
    CREATE INDEX indexName ON  `tableName` (`字段名`) 
    ```
  
  - 唯一索引：与普通索引的不同之处是，要求索引列中类的值是唯一的，但是允许有空值
  
    ```java
    CREATE UNIQUE INDEX uniqueIndexName ON `tableName`(`字段名`)
    ```

- 主键索引：不允许有空值（在B+tree中InnoDB引擎中，主键索引起了至关重要的作用）

- 创建组合索引

组合索引：包含多个字段，但是只有一个索引名称，使用查询时要遵循 **组合索引的最左前缀规则** 

```
CREATE INDEX nicknameIndex ON `tabkeName`(`字段名`,`字段名`)
```

#####  组合索引的最左前缀规则

- 不从 索引的最左列开始查询，就不能使用索引

例如：

```java
index(`c1`, `c2`, `c3`)  WHERE  `c2`=`aaa`  //就不能使用索引
```

- 查询中某个列有范围查询之后，则其右边的列都无法使用查询（多列查询）

```java
WHERE c1=`xxx` 和 WHERE c1 like `xx%`  //会使用到索引
WHERE c1=`%xx`	// 就不会使用到索引 
```

- 使用范围查询就会停止匹配，索引查询最多只适用于一个范围列
- 查询条件中包含函数或者表达式，也会导致索引失效而进行全表扫描

#####  索引的优点

* 大大减少了服务器需要扫描的数据量
* 帮助服务器避免排序和临时表
* 将随机IO 变为 顺序IO

- 在查询中使用索引，可以提高性能（使用78w条地理位置数据，不使用索引 0.174s，使用索引 0.001s）

#####  使用索引的缺点

- 创建和维护索引会耗费时间，随着数据量的增加而增加
- 索引会占用物理空间，除了数据表占用的空间外，每个索引还会占用一定的物理空间
- 当对表的数据进行插入，更新，删除的时候，索引也要动态地维护，会降低数据维护的速度

#####  什么情况下不应该创建索引

- 当表的修改，更新，删除操作远远大于查询操作的时候，不应该创建索引
- 查询中很少使用到的字段不应建立索引
- 很少数据的列（比如性别），也不应建立索引算法

#### 索引分类

#####  B-Tree索引

![image-20200808122459852](C:\Users\hg\AppData\Roaming\Typora\typora-user-images\image-20200808122459852.png)

* 叶子 节点：指针指向的是 被索引的数据
* 节点页 节点：指向下一层的节点页

B-Tree 对索引是按顺序存储的，所以很适合查找范围数据

**使用B-Tree的查询类型**

* 全值匹配：和索引中的所有列进行匹配
* 匹配最左前缀：只使用 索引的第一列
* 匹配列前缀：可以只匹配某一列的开头部分
* 匹配范围值：某一列的范围
* 精确匹配某一列，并范围匹配另一列：全值+匹配列
* 只访问索引的查询：覆盖索引

**使用 B-Tree 索引的限制**

* 如果不是从索引的最左列开始查找，就无法使用索引
* 不能跳过索引中的列
* 如果查询中有某个列的范围查询，则其右边的列都无法使用索引优化查找

**B树和B+树的区别**

* B树：非叶子节点可以存储数据
* B+树：只有叶子节点存储数据；不能在非叶子节点命中

#####  哈希索引

哈希索引 基于 哈希表 实现的，只有 **精确匹配索引所有列** 的查询才会有效。

* 对于每一行数据，存储引擎都会对**所有的索引列** 计算一个 hashcode
* 哈希索引将所有的 hashcode 存储在索引中，同时在哈希表中 保存指向每个数据行的指针

只有 Memory 引擎显示支持 哈希索引。Memory 索引支持非唯一哈希索引。如果多个列的 hashcode 相同，索引会以链表的方式 存放多个记录到同一个 hash 条目

哈希索引的限制

* 哈希索引只包含 哈希值 和 行指针，而不存储 字段值。所以不能使用 索引中的值 来避免读取行
* 哈希索引数据并 不是按照索引值 顺序存储的，所以无法用于排序
* 哈希索引 不支持 部分索引列匹配查找
* 只支持等值比较查询
* 如果哈希冲突过多，索引维护操作 的代价也会很高

InnoDB 自适应哈希索引

* 当 InnoDB 引擎注意到 某些索引值被使用非常频繁时，会在内存中 基于 B-Tree索引之上再创建一个哈希索引
* 完全自动地、内部的行为，用户无法控制

#### 高性能索引策略

##### 聚簇索引

聚簇索引：是一种数据存储方式

* 当表有 聚簇索引 时，它的数据行实际上存放在索引的叶子页
* 一个表只能有一个聚簇索引，因为无法同时把数据行 放在两个不同的位置

InnoDB 建立聚簇索引

* 通过主键聚集数据
* 如果没有定义主键，InnoDB 就会选择一个 唯一的非空索引代替
* 如果没有这样的索引，InnoDB 会隐式 定义一个主键来做聚簇索引

聚簇索引的优点

* 可以把相关的数据放在一起
* 数据访问更快
* 使用 覆盖索引 扫描的查询，可以直接使用页节点中的主键值

聚簇索引的缺点：

* 聚簇索引极大的提高的 I/O 密集型应用的性能，但是数据如果全部放在内存中，聚簇索引就没有什么优势了
* 插入速度严重依赖于插入顺序
* 更新聚簇索引列 的代价很高
* 基于聚簇索引的表在插入新行，或者主键被更新导致需要移动的时候，可能面临“页分裂”得问题
* 可能导致全表扫描变慢
* 二级索引可能比想象中的更大
* 二级索引访问 需要两次查找，而不是一次

聚簇索引 和 非聚簇索引 的区别

* 非聚簇索引：主键索引 和 其他索引 在结构上没有任何区别；叶子节点保存记录的**行指针**
* 聚簇索引：主键索引叶子节点保存**主键值、事务ID、事务回滚指针、所有剩余列**，二级索引节点保存**主键值**

![image-20200808230910123](C:\Users\hg\AppData\Roaming\Typora\typora-user-images\image-20200808230910123.png)

##### 覆盖索引

覆盖索引：一个索引包含(覆盖) 所有需要查询的 字段的值

覆盖索引的优点：

* 索引的条目远远小于是数据行的大小，所以如果只读取索引，能减少数据访问量
  * 降低缓存负载，减少数据拷贝花费的时间
  * 有利于 I/O 密集的应用，索引比数据更小，更好全部放入内存
* 因为索引按列值顺序存储的，所以对于 I/O 密集型的范围查询会比 随即从磁盘读取每一行的 I/O少很多
* 某些存储引擎(比如：MyISAM)，在内存中只缓存索引，数据则依赖于操作系统缓存。所以访问数据会发生一次系统调用，可能导致严重的性能问题
* 由于 InnoDB 有聚簇索引。所以如果二级主键能够覆盖查询，则可以避免对主键索引的二次查询

#### 编写索引的三个原则

* 单行索引很慢
  * 如果服务器从存储中读取一个数据块，只是为获得其中一行，那么就浪费了很多工作
  * 最好读取的块中能包含尽可能所需要的行
  * 使用索引可以创建 位置引用以提升效率
* 按顺序访问范围数据是很快的
  * 顺序 I/O 不需要多次磁盘寻道，所以比随机 I/O 快很多
  * 如果服务器能够按需要顺序读取数据，那么就不在需要额外的排序操作
* 索引 覆盖查询 是很快的。如果一个索引包含了查询需要的所有列，那么存储引擎就不再需要回表查找行，避免了大量的单行访问。

#### 问题

##### 为什么使用 B+ 树做索引

* B树 和 B+ 树的区别
  * B+树只有叶子节点存储数据，其余节点用来索引
  * B树的每个索引节点都有 data 域

B+ 树的两个优点

* 使用索引时，减少 IO 次数
  * B+ 树用来充当索引，一般来说 索引都比较大，为了减少内存使用，索引会被放在磁盘上
  * 如果用 B+ 树，每次可以读出尽可能多的索引，减少 IO 次数
  * B树的节点包含 data 域，会增加节点大小，增加 IO 次数
* 区间访问
  * data 域都在叶子节点，一般会进行优化，将所有的叶子节点用指针串联起来。这样遍历叶子节点就可以获得全部数据，就可以进行区间访问。（范围查询）

### 查询性能优化

#### 为什么查询会慢

* 是否请求了不必要的数据
  * 查询不必要的记录
  * 多表关联时返回全部列
  * 总数取出全部列

#### 重构查询方式

* 复杂查询分解为简单查询
* 切分查询
* 分解关联查询

#### 查询执行基础

![image-20200809202426295](C:\Users\hg\AppData\Roaming\Typora\typora-user-images\image-20200809202426295.png)

* 客户端发送一条查询给服务器
* 服务器先检查 查询缓存，如果命中了缓存，就立即返回存储在缓存中的结果。否则进行下一阶段
* 服务器端进行SQL解析、预处理，再由优化器生成对应的执行计划
* MySQL根据优化器生成的执行计划，调用存储引擎的 API 来执行查询
* 将结果返回给客户端

#### 连接查询（JOIN）

```
SELECT  xx  FROM  xx  LEFT(RIGHT/INNER) JOIN  xx  on xx.x=xx.x
```

- 左连接：左表全部展出，右表展出符合条件的
- 右连接：右表全部展出，左表展出符合条件的
- 内连接：返回两个表都有的部分
- 全连接：MySQL不能使用全连接，但是可以使用 `左连接 union 右连接` 来实现全连接

#### 为什么不能使用 select *

* 在业务方面：`select *` 会引入很多多余的字段（字段多余）
* 在数据库性能方面：
  * 缓存：`select *` 查出来的数据多，会白白占用比较多的缓存空间
  * 覆盖索引：如果仅仅检索需要的数据，可能会符合 覆盖索引 ，这样就不需要回表，减少一次检索耗时

### 查询语句

```mysql
select
	count(*)// 查个数, 
	count(distinct *)//去重查个数
	avg(*) //平均值
	sum(*) //总和
from // 哪张表
where //查询条件
having //对分组结果指定条件
order by 
	desc //降序
	asc //升序
```

* `oeder by`  默认 `asc` 升序排列

## Redis

为什么使用 Redis？

* 高性能： Redis 直接从缓存访问，不读取硬盘
* 高并发：缓存承受的并发量，远大于数据库

#### Redis 线程模型

redis 内部使用 文件事件处理器，这个文件事件处理器 是单线程的，所以 redis 被叫做 单线程的模型。

它采用 IO 多路复用机制同时监听多个 socket，根据 socket 上的事件来选择对应的事件处理器进行处理。

文件事件处理器的结构

* 多个 socket
* IO 多路复用
* 文件事件分派器
* 事件处理器（连接应答处理器、命令请求处理器、命令回复处理器）

多个 socket 可能会并发产生不同的操作，每个操作对应不同的文件事件，但是 IO 多路复用程序会监听多个 socket，会将 socket 产生的事件放入队列中排队，事件分派器每次从队列中取出一个事件，把该事件交给对应的事件处理器进行处理。

#### 常见数据结构

* String：最简单的 key-value 类型，适合于常规技术
* Hash：适用于存储对象
* List：实现为一个双向链表
* Set：set 可以自动排重
* ZSet：排序功能

#### Redis 过期设置

redis 可以设置 数据的过期时间

redis 的删除策略

* 定期删除：redis 默认每隔 100ms 就随机抽取一部分设置了过期时间的 key，检查是否过期
* 惰性删除：过期的 key 没有被定期删除 删除掉，就需要靠系统去查一下 key，才会被 redis 删除

#### Redis 内存淘汰机制

6 中淘汰策略

* volatile-lru：从已设置过期时间的数据集中，挑选最近最少使用的数据淘汰
* volatile-ttl：从已设置过期时间的数据集中，挑选将要过期的数据淘汰
* volatile-random：从已设置过期时间的数据集中，任意选择数据淘汰
* allkeys-lru：当内存不足以容纳写入新的数据时，在键空间中，移除最近最少使用的 key（最常用）
* allkeys-random：从数据集中，任意选择数据淘汰
* no-eviction：禁止驱逐数据，内存不足时，写入新数据会报错

4.0 之后新增了两个

* volatile-lfu：从已设置过期时间的数据集中，挑选最不经常使用的数据淘汰
* allkeys-lfu：当内存不足以容纳写入新的数据时，在键空间中，移除最不经常使用的key

#### redis 持久化机制

redis 支持持久化，memcached 不支持

* 快照持久化（RDB）
  * 通过创建快照来获得存储在内存里面的数据在某个时间点上的副本
  * redis 创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器；也可以保存到本地
* 追加文件（AOF）
  * 与 RDB 相比，AOF持久化 的实时性更好

#### redis 事务

通过 `MULTI EXEC WATCH` 等命令来实现事务功能

* 事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制
* 并且在任务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，才会去处理其他客户端的命令请求。

#### 缓存雪崩、缓存穿透、缓存击穿

缓存雪崩：缓存同一时间大面积失效（比如同时过期），所以后面的请求都落在数据库上，造成数据库短时间内承受大量请求而崩掉

解决方法：

* 事前：尽量保持 redis 的高可用性，发现机器宕机之后尽快补上。选择合适的内存淘汰策略
* 事中：本地 ehcache 缓存 + hystrix 降级，避免 MySQL 崩掉
* 事后：利用持久化机制保存的数据，尽快进行恢复缓存



缓存击穿：某一个过期的 key，被超高并发的访问

解决方法：

* 设置热点数据永不过期
* 使用互斥锁



缓存穿透：大量请求的 key 不在缓存中也不在数据库中，导致请求直接落在了数据库上，根本没有经过缓存这一层。

解决方法：

* 缓存无效 key：如果 redis 和 数据库 都查不到某个 key 的数据，就写一个到 redis 中，并设置过期时间
* 布隆过滤器：先使用布隆过滤器判断请求是否的值是否存在于布隆过滤器中，如果不存在，就返回参数错误。

##### 布隆过滤器

BloomFilter相当于一个不太精确的Set集合，通过其Contains方法来判断某个元素是否存在。

- 如果判断一个元素不存在，那么这个元素一定不存在
- 如果判断一个元素存在，那么这个元素不一定存在

BloomFilter在Redis中，对应着一个大型的位数组和几个不同的hash函数

添加操作：

- 根据hash函数，来对元素进行hash计算得索引值
- 然后用索引值对数组长度取模，得到位置
- 几个不同的hash函数将得到几个不同的位置，将数组中的对应位置设置为1

检查元素是否存在

- 根据hash函数计算元素的索引值
- 索引值对数组长度取模，得到位置
- 检查几个位置是否全部为1。如果全部都是1，说明元素可能存在；如果不全为1，说明元素一定不存在

## 一致性哈希算法

参考链接：[一致性hash](https://www.jianshu.com/p/e968c081f563)

### 使用hash的问题

hash算法通过取模运算（对服务器的数量取模），来进行缓存查找，必然会出现一下几个问题

- 增加一台服务器的时候，所有缓存的位置都会改变
- 减少一台服务器的时候，所有的缓存位置都会改变

这个问题会造成缓存雪崩（由于原有的缓存失效，新缓存未到期间，原本应该访问缓存的请求都去查询数据库，对数据库CPU和内存造成了巨大压力，严重的会造成数据库宕机，引发一系列反应，造成系统崩溃）

### 一致性hash算法

一致性hash也是采用的取模运算来找到数据的位置，只不过一致性hash算法不是对服务器的数量取模，而是对2^32-1取模。

- 一致性hash算法将整个hash空间组成一个虚拟的圆环，0 ~ 2^32-1，整个空间按顺时针方向组织。
- 将服务器的主机名或者ip地址做为关键字进行hash，计算出每个服务器的位置。
- 接着对数据的key值使用相同的函数hash计算出哈希值，确定此数据在圆环上的位置。
- 从此位置顺时针行走，遇到的第一个服务器就是此数据定位到的服务器。

### 一致性hash算法的特点

- 单调性：已经有一些请求通过哈希分配到了相应的服务器进行处理，此时有又有新的服务器加入到系统中，应该保证原有的请求可以被映射到原有的或者新的服务器中去，而不是映射到原来的其它服务器上去。
- 分散性：一致性hash拥有很低的分散性。分散性是指，在分布式环境中，客户端请求时可能不知道所有服务器的存在，只知道一部分服务器的存在，如果多个客户端都把部分服务器作为完整的hash环，可能导致相同的请求被映射到不同的服务器。分散性是指以上情况发生的严重程度。
- 平衡性：每台服务器处理请求的数量大致相同（通过虚拟节点来实现）



为什么可以降低分散性：因为采用一致性hash算法，请求数据的key值映射的位置都是确定的，只要几台服务器都知道存储该数据的服务器，就可以找到该数据，对能否知道其他服务器没要求。如果采用一般的hash算法，hash运算会严重受到服务器数量的影响。

### 如何解决数据倾斜问题

一致性hash算法通过增加虚拟节点来实现，即对每一个服务器节点计算多个hash，在每个计算结果位置都放置一个此服务节点，具体做法可以在服务器后面加编号来实现，再多一步虚拟节点到实际节点的映射就可以。在实际应用中，将虚拟节点设置为32甚至更大，因此很少的节点也可以做到数据均衡分布。

# Mybatis

## # 和 $ 的区别

* `${}`：不会加上 ``
* `#{}`：会在参数上加上 ``

## xml 常见的标签

`select insert update delete`

`resultMap parameterMap sql include `

## Dao 接口工作原理

Dao 接口，就是人们常说 Mapper 接口

* 接口的全限定名，是映射文件中的 `namespace` 的值
* 接口的方法名，是 `MappedStatement` 的 id 值
* 接口方法内的参数，就是传递给 sql 的参数

`Mapper` 接口是没有实现类的，当调用接口方法时，接口全限定名+方法名 拼接为字符串 作为 key 值，可唯一定位一个 `MappedStatement`

举例：`com.mybatis3.mappers.StudentDao.findStudentById` 

可以唯一的定位到 `com.mybatis3.mappers.StudentDao` 下面 `id=findStudentById`  的 `MappedStatement`

在 Mybatis 中，每一个 `<select> <insert> <update> <delete>`  标签，都会被解析为 `MappedStatement`

## Mybatis 封装 sql 执行结果

* `<resultMap>` 标签，逐一定义 列名和对象属性名 之间的映射关系
* 使用 sql 列的别名功能，将列别名书写为对象属性名

## Executor 执行器

* `SimpleExecutor`：每执行一次 update 或 select，就会开启一个 statement 对象，用完之后立即关闭 statement 对象
* `ReuseExecutor`：执行 update 或 select，以 sql 作为 key 查询 statement 对象，存在就是用，不存在就创建。用完之后不会关闭 statement 对象，而是放置于 Map<String, Statement> 内，供下一次使用
* `BatchExecutor`：执行 update，将所有 sql 都添加到 批处理中（ addBatch()），等待统一执行（executeBatch()），它缓存了多个 statement 对象，每个 statement 对象都是 addBatch()  完成后，等待逐一执行 executeBatch() 批处理

# 计算机网络

## TCP/IP 分层管理

* 应用层：
  * FTP：文件传输协议
  * HTTP：生成针对目标Web服务器的HTTP请求报文；对Web服务器的请求内容进行处理
    * 请求报文：请求方法、请求URI、协议版本号、可选的请求首部字段、内容实体
    * 响应报文：协议版本号、状态码、状态码的原因短语、可选的响应首部字段、实体主体
  * DNS：提供 通过域名查找 IP 地址，或者逆向查域名的服务
* 传输层：
  * TCP：分割/重组 请求报文为报文段，每个报文段可靠传输
  * UDP
* 网络层：
  * IP：搜索地址
  * ARP：解析地址的协议。根据IP地址反查对应的MAC地址
  * STP：生成树协议。按照树的结构来构造网络拓扑，消除网络中的环路；避免环路的存在造成广播风暴
* 链路层：可以提供的服务包括：无确认的无连接服务、有确认的无连接服务、有确认的有链接服务

## 三次握手

![image-20200810092109642](C:\Users\hg\AppData\Roaming\Typora\typora-user-images\image-20200810092109642.png)

第一次握手

* 客户端发送 syn 包到服务器，进入 SYN_SEND 状态
  * SYN：TCP 的 SYN 标志为 1
  * seq：客户端初始序号，保存在包头的序列号字段里面
* Client什么都不能确认，Server确认对方发送正常

第二次握手

* 服务器收到 syn 包，确认客户的 seq（ack=j+1）并发送自己的 SYN 包，进入 SYN_RECV 状态
* Client确认自己发送、接受正常，对方发送、接收正常；Server确认对方发送、自己接受正常

第三次握手

* 客户端收到 SYN+ACK 包，向服务器发送确认包 ACK（ack=k+1）
* Client确认自己发送、接受正常，对方发送、接收正常；Server确认自己发送、接受正常，对方发送、接收正常

## TCP 和 UDP

![image-20200815110312611](C:\Users\hg\AppData\Roaming\Typora\typora-user-images\image-20200815110312611.png)

### TCP 实现可靠性传输

* 校验和
  * 发送方在发送数据之前先计算校验和，并进行校验和的填充；接收方收到数据后，以相同的方式计算校验和，与发送方的进行比对
  * 如何计算：将发送的数据段都当作 16 位的整数，把这些整数加起来，前面的进位补在后面，最后取反，得到校验和。

* 序列号和确认应答

  * 序列号：TCP在传输时，将每个字节的数据都进行了编号，这就是序列号。为了识别是否已经接收数据，以及判断是否需要接收数据（在收到数据时，不需要一点点去判断是否重复，只需要看序列号就可以判断数据是否重复）
  * 确认应答号：自己下一步应该接受的序列号（告诉发送方，接收到了哪些数据，下一次的数据从哪里发送）

* 超时重传：发送方在发送完数据后，等待一段时间，时间到达还未收到ACK报文，就对刚才发送的数据进行重传。

  * 如何计算：每次发包时，都会计算往返时间 及其 偏差。两者之和是重发超时 的时间（超时以 500ms 作为一个单位进行控制，每次判定超时重发的超时时间，都是 500ms 的整数倍）

* 连接管理：TCP是有链接的协议

  * 三次握手
  * 四次挥手

* 流量控制：TCP 根据接收端对数据的处理能力，来决定发送端的发送速度，这个机制就是流量控制

  * 接收端接收到数据后，会对其进行处理
  * 如果发送端发送的数据太快，就会导致接收端的缓冲区很快被填满。如果此时发送端继续发送数据，那么接下来的数据都会丢包，然后就会超时重传。
  * TCP 报头信息中，有一个 16 位字段的窗口大小。这个窗口大小实际上是接收端 接收数据缓冲区 的大小，接收端会在确认应答发送 ACK 的时候，将自己的即时窗口大小填入，跟随 ACK 报文一起发送过去。发送方会根据 接收方窗口大小的值 来改变自己的发送速度。如果为0，就会停止发送。并定期向接收端发送窗口探测数据段，让接收端 把窗口大小告诉发送端。

* 拥塞控制：cwnd(拥塞窗口)，是发送方一个动态变化的窗口

  * 慢启动：TCP 采用慢启动的机制，来避免大量拥塞。开始时设置拥塞窗口为1，慢启动算法每经过一个传输轮次，拥塞窗口都会加倍。

  * 拥塞避免：为了防止 cwnd 增长过快导致网络拥塞，所以需要一个 **慢开始门限 ssthresh**。拥塞避免让 cwnd 的增长不再是翻倍的，而是每次增加1，达到线性增长。

    **AIMD**：加法增加，乘法减小

    * 乘法减小：无论是慢启动还是拥塞控制，只要网络出现超时，就将 cwnd 设置为 1，ssthresh 设置为 cwnd 的一半，然后执行 慢启动 算法
    * 加法增加：网络频发超时重传时，ssthresh 下降的就会很快，加法增加是执行 拥塞避免 算法，使 cwnd 的增长变缓，防止过早的出现拥塞

  * 快重传：接收方在收到失序报文段后，就立即发出重复确认，而不要等待自己发送数据时才稍带确认。发送方在收到三个重复的ACK之后，就会尽早重传未被确认的报文段。

  * 快恢复：接收方收到三个ACK之后，就会把 ssthresh 减半，然后将 cwnd 设置为 ssthresh 的一半，执行拥塞避免算法，窗口缓慢增大。

### 滑动窗口

* 利用窗口控制提高速度（滑动窗口机制）

  * 优点：避免了每发一个段就要等待一次确认应答，带来的性能降低的问题。

    确认应答的不再以每个分段，而是以一个更大的单位进行确认，减少转发时间。

  * 窗口大小：指的是无需等待确认应答，而可以继续发送数据的最大值

    这个机制使用的大量的缓冲区，数据发出后若如期收到确认应答，就不用再进行重发，此时始数据就可以从缓存区清除。

## HTTP 协议

### HTTP报文

![image-20200818175459308](C:\Users\hg\AppData\Roaming\Typora\typora-user-images\image-20200818175459308.png)

* 请求行：用于请求的方法，请求 URI 和 HTTP 版本号
* 状态行：表明响应结果的状态码，原因短语和HTTP版本
* 首部字段：请求和响应 的各种条件和属性的各类首部
  * 通用首部
  * 请求首部
  * 响应首部
  * 实体首部
* 其他：可能包含HTTP里未定义的首部（cookie等）

### HTTP 加速传递的工作

* 编码提升传输速率
  * 压缩传输 的内容编码（类似于压缩文件）
  * 分割发送 的分块传输编码：传输大容量数据时，通过把数据分割成多块，来让浏览器逐步显示
* 获取部分内容：可以从下载中断 处恢复下载

### 长连接 和 短连接

* HTTP 1.0 中默认使用短连接：客户端和服务器每进行一次 HTTP 操作，就要建立一次连接任务结束就中断。当客户端访问某个 HTML 或其它类型的 Web 页中包含有其他的 Web 资源，每遇到一个 Web 资源，浏览器就会重新建立一个 HTTP 会话

* HTTP 1.1 起，默认使用长连接。响应头多了这行代码`Connection:keep-alive`

  在使用长连接时，一个网页打开完成后，客户端和服务器之间用于传输 HTTP 数据的 TCP 连接不会关闭，客户端再次访问这个服务器时，会继续使用这一条已经建立的连接，长连接不会永久有效，有一个保持时间。

### Get 和 Post 区别

* Get 请求
  * 请求的数据附在 URL 后面，以 ？分割 URL 和 传输数据。多个参数用 & 连接
  * 浏览器和服务器 对 Get请求长度有限制
  * GET 提交的数据，会显示在 URL 上
* Post 请求
  * 把提交的数据放置在 HTTP包中

### session 和 cookie

* cookie：用来保存用户信息，**保存在浏览器端**
  * 通过在 请求/响应 报文中写入 cookie 信息(sid) 来控制客户端的状态
  * 可以在 cookie 中保存已登录过的用户的信息，下次访问网站的页面是，就可以自动填写一些登录信息
  * 保持登陆状态，存放一个 token 在cookie 中，下次登陆的时候，只需要根据 token 来查找用户即可
  * 登陆之后，访问替他页面不用重新登陆
* session：通过服务端记录用户的状态，**保存在服务器端**
  * 购物车场景
  * 如果浏览器禁止了 cookie，那么可以把 cookieId 写入 url 中来传递

### 状态码

![image-20200818184538081](C:\Users\hg\AppData\Roaming\Typora\typora-user-images\image-20200818184538081.png)

## Web 服务器

### 代理

* 缓存代理：代理转发响应时，缓存代理会预先将资源副本保存在代理服务器上；当代理再次接收到对相同资源的请求时，就可以不从源服务器那里获取资源，而是将之前缓存的资源作为响应返回
* 透明代理：不对报文做人个加工的代理类型

### 网关

能够使通信线路上的服务器提供非 HTTP 协议的服务

利用网关能提高通信的安全性，因此可以在客户端与网关之间的通信线路上加密，以确保连接的安全

### 隧道

目的：确保客户端能与服务器进行安全的通信

方法：简历一条客户端与服务器的通信线路，使用SSL等手段进行加密

## 浏览器输入网页、打开过程

1. 浏览器输入域名
2. 浏览器查找域名的 IP 地址
   1. 查找浏览器缓存：浏览器一般会缓存DNS记录一段时间
   2. 查找系统缓存：如果上一步找不到 IP，浏览器会进行系统调用，查找本机的 hosts 文件，如果找到，返回 IP
   3. 查找路由器缓存：如果前两步都找不到 IP，就将请求发送给路由器，查找 ISP 服务商 缓存DNS的服务器，如果找到，返回 IP
   4. 递归查询：如果上面步骤找不到，则 ISP 的 DNS服务器会进行递归查询。递归查询是，如果主机访问的本地域名服务器不知道被查询域名的ip地址，那么本地域名服务器就会以DNS客户的身份，向其他根域名服务器发出查询请求报文，而不是让该主机自己进行下一步的查询
   5. 迭代查询：本地域名服务器采用迭代查询。它先向一个根域名服务器查询，如果根域名服务器不知道查询域名的IP地址，就会告诉本地域名服务器下一步应该查询哪一个域名服务器，然后本地域名服务器自己进行后续的查询（和递归查询的区别就是，被请求的服务器 会不会替代 发出请求的服务器进行接下来的查询）
3. 浏览器 与 目标服务器建立 TCP 连接
   1. 主机浏览器通过 DNS 解析得到了目标服务器的 IP 地址后，与服务器建立 TCP 连接
   2. TCP 连接的建立，采用三次握手
4. 浏览器 通过 http协议 发送请求
5. 某些服务器会做永久重定向响应：某些大型的网站存在多个主机站点，为了 负载均衡 或 导入流量，不会直接返回页面，而是重定向到其他的服务器。
6. 浏览器跟踪重定向
7. 服务器请求处理
8. 服务器发出一个 HTML 响应
   1. 返回码是 `200 OK`，表示服务器可以响应请求，返回报文
   2. 报头中的 `Content-type` 是 `text/html` ，浏览器会议 html 形式呈现，而不是下载文件
9. 释放 TCP 连接：四次挥手
10. 浏览器显示页面：在浏览器没有完整接受全部的 HTML 文档时，就已经开始显示页面
11. 浏览器发送获取 嵌入在HTML中的 其他内容

* DNS 解析
* TCP 连接
* 发送 HTTP 请求
* 服务器处理请求 并返回 HTTP 报文
* 浏览器解析渲染 页面
* 连接结束

![image-20200815110715418](C:\Users\hg\AppData\Roaming\Typora\typora-user-images\image-20200815110715418.png)

## 路由器和交换机

|          | 路由器         | 交换机             |
| -------- | -------------- | ------------------ |
| 工作位置 | 网络层         | 链路层             |
| 转发依据 | IP地址         | Mac地址            |
| 功能     | 连接不同的网络 | 连接局域网内的电脑 |

## Http 和 Https

* 端口
  * http：url 默认开头为 `http://` ；默认端口为 80
  * https：url 默认开头为 `https://` ；默认端口为 443
* 安全性 和 资源消耗
  * HTTP 协议运行在 TCP 之上，传输内容为明文，客户端和服务器端都无法验证对方身份。
  * HTTPS 运行在 SSL/TLS 之上的 HTTP 协议，SSL/TLS 运行在 TCP 之上，所有传输内容都经过加密，加密采用对称加密，但是 **对称加密的密钥用服务器的证书进行了非对称加密**
    * 公有密钥：加密使用
    * 私有密钥：解密使用
  * HTTPS 更安全，HTTP 消耗资源更少

## IP 

### IP 地址

每一类地址由两个固定长度的字段组成：网络号（net-id）+ 主机号（host-id）

![image-20200829135628308](C:\Users\hg\AppData\Roaming\Typora\typora-user-images\image-20200829135628308.png)

* A类地址：一字节的网络地址 + 三字节的主机地址（网+主+主+主）

  * 网络地址的二进制范围是 0000 0000 ~ 0111 1111，即 0~127

  * 由于A类地址的 第一个 和 最后一个地址块 保留使用。所以A类地址的有效网络范围是 1~126

* B类地址：网+网+主+主；1000 0000 ~ 1011 1111，即 128~191

* C类地址：网+网+网+主；1100 0000 ~ 1101 1111，即 192~223

* D类地址：224~239

![image-20200829140228410](C:\Users\hg\AppData\Roaming\Typora\typora-user-images\image-20200829140228410.png)

### 划分子网

IP 地址中，新增加了 ”子网号字段“，使两级的IP地址 变为 三级的IP地址

子网掩码：一种用来指明一个 IP地址 的哪些位标识的是主机所在的子网，以及哪些位标识的是主机的位掩码。

* 子网掩码不能单独存在，必须结合IP地址一起使用
* 子网掩码的唯一作用就是，将某个IP地址划分为 网络地址 和 主机地址两部分

子网掩码的使用

* IP地址 & 子网掩码 = 子网的网络地址

* 根据ABC类地址 和 子网掩码，可以查看划分子网时，借用了几个1的主机号来划分，这样可以用剩下的 0 计算出每个子网可以容纳的主机个数，**不过要记得-2，一位内主机号全为1的IP称为广播地址，主机号全为0的IP称为网络号**

例题：

1. 一个C类网络IP地址使用掩码255.255.255.224，每个子网可以容纳几台主机？
   * 224 借用了3个主机号来划分子网，所以还剩五位主机号，个数是 2^5-2 = 30 个
2. 一个单位得到一个B类网络地址，划分出200个子网后，掩码为？
   * 200 个子网，2^7=256>200，所以需要占用7个主机号来划分子网，即 11111111 11111111 11111110 00000000，所以子网掩码是 255.255.254.0
   * 每个子网内的主机数位 2^9-2 = 510 台

## spdy

### HTTP 的瓶颈

场景：海量的用户发布大量的内容，web网站会产生大量的内容更新。服务器需要尽可能实时的展示更新的内容

问题：HTTP无法很好的处理这个实时更新的问题。因为使用HTTP去探知是否内容有更新，就必须频繁的从客户端到服务端进行确认。如果没有更新，就会有徒劳通信。

造成瓶颈的 HTTP 标准

* 一条连接上只能发送一个请求
* 请求只能从客户端开始

### Ajax

利用 js 和 DOM，来实现 局部Web页面替换加载的异步通信手段

* 优点：和之前的同步通信相比，由于只更新了一部分页面，响应中传输的数据量会减少
* 局限：无法克服HTTp协议的本身的问题，仍然会有大量的无效请求

### Comet

一旦服务端有更新，content不会让请求等待，而是直接给客户端返回响应

这是一种通过延迟应答，模拟实现服务器端向客户端推送的功能

特点：

* 为了实现推送功能，comet 会先将响应置于挂起状态，当服务端有内容更新的时候，再返回该响应
* 为了维持连接，会消耗更多的资源

### SPDY 协议

特点：

* 在 TCP/IP 的应用层与运输层之间 添加会话层
* 在通信中使用 SSL 加密，来保证安全问题

优点：

* 多路复用流：单一的 TCP 连接，可以无限制处理多个 HTTP 请求
* 赋予请求优先级：可以给请求逐个分配优先级顺序

* 压缩HTTP头部：减少通信的数据量
* 推送功能：支持服务器主动向客户端推送数据

### WebSocket

使用 HTTP 西医，无法解决 HTTP 存在的问题

WebSocket 是 web浏览器 与 web服务器 之间全双工通信标准

特点：

* 推送功能：支持服务器向客户端推送数据，不必等待客户端请求
* 减少通信量：建立起 WebSocket 连接之后，就希望一直保持连接状态

# 操作系统

## 进程和线程

### 进程通信方式

* 管道
  * 匿名管道：在内核中申请一块固定大小的缓存，程序拥有读写的权利，一般使用fork函数实现父子进程之间的通信
  * 有名管道：在内核中申请一块固定大小的缓存，程序拥有读写的权利，没有血缘关系的进程也可以进行进程间的通信
  * 特点：
    * 面向字节流
    * 生命周期和内核一样
    * 自带同步互斥机制
    * **半双工，单向通信**，两个管道实现双向通信
* 消息队列：在内核中创建一个队列，每个元素是一个数据报，不同的进程通过句柄去访问这个队列。
  * 不足
    * 每个消息队列的 总的字节数是有上限的
    * 系统上消息队列的总数也有一个上限
  * 特点
    * 消息队列可以认为是一个全局的链表，节点存放着数据报的类型和内容
    * 允许一个或多个进程写入或读取消息
    * 生命周期随内核
    * 可实现双向通信
* 信号量：信号量是一个计数器，用来控制多个进程对共享资源的访问，它常作为一个锁机制，防止某进程在访问共享资源时，其他进程也访问该资源。
  * 在内核中创建一个信号量集合（本质是个数组），数组元素都是1，使用P操作进行-1，使用V操作+1
  * P(sv)：如果sv的值大于0就减一；如果值等于0，就挂起该线程
  * V(sv)：如果有其他进程因为等待sv被挂起，就让他恢复运行；如果没有，sv就+1
  * PV用于同一进程，实现互斥
  * PV用于不同进程，实现同步
* 共享内存：将一块物理内存，映射到不同进程的虚拟地址空间中，实现不同进程对资源的共享。是最有效的进程通信方式
  * 特点
    * 不需要用户态到内核态的频繁切换和拷贝数据，直接从内存读取
    * 共享内存是临界资源，操作时需要保证原子性（使用信号量或者互斥锁）
    * 生命周期随内核
* socket：使用socket进行通信的进程，即可以是同一台计算机的进程，也可以是通过网络连接起来的不同计算机上的进程
  * 套接字属性
    * 套接字的域：指定通信中使用的网络介质
    * 套接字类型：
      * 流套接字：使用TCP/IP实现（TCP的优点）
      * 数据报套接字：UDP（UDP的不足）
    * 套接字协议：一般使用默认值

### 线程间通信方式

线程间通信的目的主要是用于 **线程同步**，所以线程没有像进程通信中的用于数据交换的通信机制

* 锁机制：互斥锁、条件变量、读写锁
* 信号量机制：无名线程信号量、命名线程信号量
* 信号机制：类似于进程间的信号处理

### 线程同步

* 阻塞同步：信号量、互斥量
* 非阻塞同步：CAS

### 进程调度算法

* 先到先服务
* 短作业优先
* 时间片轮转
* 多级反馈队列
  * 设置多个就绪队列，为每个队列赋予不同的优先级，从第一个开始逐渐降低，级别越高，时间片越小
  * 每个队列都采用 先来先服务。轮到该进程时，要是在时间片内完成，就撤离操作系统；否则调度程序将其转入第二队列的末尾。若线程最后被调到N队列中，就采用时间片轮转
* 优先级调度

## 内存管理

### 物理地址 和 逻辑地址

* 物理地址：加载到 内存寄存器 中的地址，内存单元的真正地址
* 逻辑地址：CPU 生成的地址。逻辑地址是编程使用的，并不唯一

### 内存管理机制

* 连续分配
  * 块式管理：内存分为几个固定大小的块，每个块中只包含一个进程。如果程序运行需要内存的话，操作系统就分配给它一块。会造成大量浪费
* 非连续分配
  * 页式管理
    * 把主存分为大小相等且固定的一页一页的形式，页较小。相对于块式管理的划分力度更大，提高了利用率，减少了碎片。
    * 页式管理通过页表对应逻辑地址和物理地址。
  * 段式管理：页式管理虽然提高了利用率，但是页式管理中的页没有实际意义。
    * 段式管理把主存分为一段段的，每一段空间比每一页小。
    * 而且每一段都是有实际意义的，每个段定义了一组逻辑信息。
    * 段式管理通过段表对应逻辑地址和物理地址
  * 段页式管理：先把贮存分为若干段，每段又分为若干页

### 快表和多级页表

快表：加速 虚拟地址 到 物理地址 的转换  **局部性原理**

* 根据虚拟地址中的页号 查找 快表
* 如果该页在快表中
  * 就直接从 快表中读出物理地址
* 如果该页不在快表中
  * 就访问内存中的页表，再得到物理地址
  * 更新快表，将页表中的该映射表项添加到快表
  * 快表满后，根据淘汰策略换掉其中的页

多级页表：避免把全部页表一直放在内存中，占用过多空间

多级页表为什么可以节约空间？**局部性原理**

* 二级页表不一定要创建：可以在一级页表被用到的时候，再创建二级页表。（相对于不分级的页表，分级页表的 一级页表 可以使用更少的空间来覆盖全部的内存）
* 二级页表可以不存在主存，可以放到磁盘中

### 分页机制 和 分段机制

共同点

* 分页、分段机制，都是为了提高内存的利用率，产生较少的内存碎片
* 页和段都是离散存储的，所以两者都是离散分配内存的方式。但是每个段和页中的内存是连续的

区别

* 页的大小式固定的，由操作系统决定；段的大小不固定，取决于我们当前运行的程序
* 分页仅仅是为了满足 操作系统 内存管理的 需求，而段是逻辑信息的单位，在程序中可以体现为 代码段、数据段，能够更好的满足用户的需求

### CPU寻址、虚拟寻址空间

虚拟寻址：现代处理器使用的一种 寻址方式。

* 使用虚拟寻址，CPU 需要将虚拟地址翻译成物理地址，这样才能访问到真实的物理内存
* 内存管理单元（MMU）：完成虚拟地址到物理地址转换的硬件

为什么需要 虚拟地址空间？

程序直接访问和操作物理内存的问题

* 用户任意访问内存，寻址内存的每个字节，容易破坏操作系统，造成操作系统崩溃
* 难以运行多个程序。多个程序同时运行，可能会覆盖内存地址之前的赋值

通过虚拟地址访问的优势

* 程序可以使用一系列相邻的虚拟地址，来访问物理内存中 不相邻的 大内存缓冲区
* 程序可以使用一系列虚拟内存，来访问大于可用物理内存的内存缓冲区（可以把不需要的移动到磁盘，时间换空间）
* 不同进程的使用的虚拟内存彼此隔离

## 虚拟内存

虚拟内存 

* 为每个进程提供了一个一致的、私有的地址空间，让每个进程产生了一种自己在独享主存的感觉（每个进程拥有一片连续完整的内存空间）
* 重要意义是，它定义了一个连续的虚拟地址空间，并且 把内存扩展到硬盘空间

局部性原理

* 时间局部性：如果系统中某条指令一旦执行，不久后可能再次执行；如果某个数据被访问过，不久后该数据可能会被再次访问
* 空间局部性：一旦访问了某个存储单元，不久后，其附近的存储单元也会被访问

虚拟存储器

* 程序在运行时，可以将程序的一部分装入内存，而将其他部分留在外存，就可以启动程序执行。所以我们运行软件的内存大小实际上是可以比计算机系统实际内存大的。在运行时当访问的信息不在内存时，由操作系统将所需的部分调入内存，然后继续执行
* 另一方面，操作系统将内存中暂时不使用的内容放到外存上，从而腾出空间存放将要调入内存的信息

### 虚拟内存技术的实现

虚拟内存的实现，建立在 离散分配的 内存管理方式的基础上

* 请求分页存储管理：建立在分页管理之上，为了支持虚拟存储器功能 增加了 **请求调页功能和页面置换功能**
  * 作业开始运行之前，仅装入当前要执行的部分段即可运行
  * 假如在作业运行的过程中发现要访问的页面不存在，则由处理器通知操作系统按照对应的页面置换算法将相应的页面调入内存，同时也可以将暂时不用的内存置换到外存中
* 请求分段存储管理：建立在分段管理之上，增加了 **请求调段、分段置换功能** 
* 请求段页式存储管理



分页存储管理 与 请求分页存储管理 的区别？

* 请求分页存储管理，建立在分页管理之上。它们的根本区别是**是否需要将程序全部所需的全部地址空间都装入主存**
  * 请求分页存储管理不要求 将作业全部地址空间 同时装入内存，所以 可以提供 虚存
  * 分页存储管理必须将作业空间都加入内存，不可以提供 虚存

### 页面置换算法

* OPT（最佳页面置换）：淘汰以后永不使用的，或者是在最长时间内不再被访问的页面，这样可以保证获得最低的缺页率。（太理想了，无法实现）
* FIFO（先进先出页面置换算法）：淘汰最先进入的页面，即选择在内存中驻留时间最久的页面进行淘汰
* LRU（最近最久未使用页面置换算法）：赋予每个页面一个访问字段，用来记录一个页面自上次被访问以来所经历的时间 T。淘汰的时候，选择 T 最大的页面进行淘汰。
* LFU（最少使用页面置换算法）：选择在之前时期，最少使用的页面作为淘汰页

# Linux

## 常用命令

* `ctrl-c`：发送 `SIGINT` 信号给前台进程组的所有进程。用于终止正在运行的程序
* `ctrl-z`：发送 `SIGTSTP` 信号给前台进程组中的所有进程，常用于挂起一个进程
* `ctrl-d`：不发送信号，而是表示一个特殊的二进制值，表示 `EOF`，作用相当于在中断输入 `exit` 后回车
* `ctrl-\`：发送 `SIGQUIT` 信号给前台进程组中的所有进程，终止前台进程并生成 core 文件
* `ctrl-s`：中断控制台输出
* `ctrl-q`：恢复控制台输出
* `ctrl-l`：清屏

获取 `shell` 脚本参数

* `$0`：当前脚本的文件名
* `$n`：传递给简本或函数的参数。n 是一个数字，表示第几个参数。例如，第一个参数是 $1，第二个参数是 $2
* `$#`：传递给脚本或函数的参数个数
* `$*`：传递给脚本或函数的所有参数
* `$@`：传递给脚本或函数的所有参数。被双引号(" ")包含时，与 `$*` 有所不同
* `$?`：上个命令的退出状态，或函数的返回值
* `$$`：当前 Shell 进程 ID。对于 Shell 脚本，就是这些脚本所在的进程ID

## 文件

### 权限

使用 `chomd` 命令改变文件权限

文件的基本权限有 九个，`owner group others` 分别对应着 `read write execute` 三种权限

文件权限字符：`-rwxrwxrwx` 三个一组，数组话：`r 4; w:2; x:1`

题目：文件目录 data 当前权限为`rwx --- ---`，只需要增加 用户组 可读可执行权限，但不允许写操作。命令为：`chmod+050data`

分析：给用户组加权限，所以前后都为0（`0*0`），读+执行 = 4+1=5，所以命令为 050

### 创建文件

```java
touch /test
a = `touch /test` :表示转义，`` 中的内容会被执行，即执行 touch /test 创建一个文件
>/test : 表示输出重定向，将要输出的内容写入 /test 中，若是没有 /test文件则创建再写入   
```

# 笔试选择

## Java基础

* `switch case` 不加 `break` 就会一直执行下去

* `try catch` 抛出异常，只会抛出一个

* ++(i++) ：会报错。因为 i++ 会先将 i 放到一个临时变量中去，然后返回临时变量的值。单目运算符 ++ 后面不能跟一个 字面量。类似于 ++1 也会报错。

* a += b 和 a=a+b 的区别

  ```java
  byte a = 1;
  // 执行下面的第一行语句分两步
  // a+4 的结果会强转为int
  // 然后 a=a+4，就是把 int 类型 赋给 byte 类型，会报错，因为类型不匹配
  a = a+4;
  // += 在Java中算是一个运算符，所以最后会强转为 int，不会报错
  a += 4;
  ```

* ```java
  String str = "java"+"and"+"python";
  //只会创建一个对象，因为字面量"+"的拼接是在编译期间进行的，拼接后的字符串放到字符串池中
  //字符串的"+"操作是在运行时进行的，新创建的字符串放在堆中
  ```

* `try catch finally`

  * 先执行 try，return 的值会保存在临时空间
  * 执行 finally 时，如果 finally 有return，会刷新临时空间的值（如果没有return，那它对变量的更改不会保存）
  * 方法结束时返回临时空间的值

## JVM

* JVM命令

  * jps：查看本机java进程信息。
  * jstack：打印线程的**栈**信息，制作线程dump文件。
  * jmap：打印内存映射，制作**堆**dump文件
  * jstat：性能监控工具
  * jhat：内存分析工具
  * jconsole：简易的可视化控制台
  * jvisualvm：功能强大的控制台

* JVM 各区域 大小参数

  * Xmx：最大堆大小 **10240m**
  * Xms：初始堆大小 **10240m**
  * Xmn：年轻代大小 **5120m**
  * XXSurvivorRatio：年轻代中2个Survivor与eden的比，3表示Survivor：eden=2:3，故Survivor区总大小=**5120**/5\*2=2048
  * *XXNewRatio：年老代（不含永久代）与年轻代（eden+2*survivor）的比值

* 被动引用不会**触发子类初始化**

  * 子类引用父类的静态字段，只会触发子类的加载、父类的初始化，不会导致子类初始化
  * 通过数组定义来引用类，不会触发此类的初始化
  * 常量在编译阶段会进行常量优化，将常量存入调用类的常量池中， 本质上并没有直接引用到定义常量的类，因此不会触发定义常量的类的初始化

  ```java
  public class P {
  	public static int abc = 123;
  	static{
  		System.out.println("P is init");
  	}
  }
  public class S extends P {
  	static{
  		System.out.println("S is init");
  		}
  	}
  public class Test {
  	public static void main(String[] args) {
  		System.out.println(S.abc);
          // P is init
          // 123
  	}
  }
  ```

  

## 数据结构

### 树

* 入度 和 出度 是图中顶点的定义，树的度只是指的儿子节点数
  * 哈夫曼树 只能有 度为0和2 的节点

### 图

* 拓扑排序：如果图中有一条从u到v的路径，则顶点v必须出现在顶点u之后。找出顶点活动网中的拓扑序列称“拓扑排序”。

## 排序

![img](https://images2018.cnblogs.com/blog/849589/201804/849589-20180402133438219-1946132192.png)

* 堆排序删除元素：将要删除的节点和最后一个节点交换位置；删除最后一个节点；调整堆；

## 计网

* IP 地址聚合，取网络地址的最大相同部分
* 

# 面经

- [ ] https://www.nowcoder.com/discuss/219782
- [ ] https://www.nowcoder.com/discuss/219804
- [ ] https://www.nowcoder.com/discuss/220317
- [ ] https://www.nowcoder.com/discuss/220423
- [ ] https://www.nowcoder.com/discuss/220454
- [ ] https://www.nowcoder.com/discuss/220473
- [ ] https://www.nowcoder.com/discuss/220542
- [ ] https://www.nowcoder.com/discuss/220594
- [ ] https://www.nowcoder.com/discuss/220608
- [ ] https://www.nowcoder.com/discuss/220895
- [ ] https://www.nowcoder.com/discuss/221033
- [ ] https://www.nowcoder.com/discuss/221099
- [ ] https://www.nowcoder.com/discuss/225173
- [ ] https://www.nowcoder.com/discuss/225278
- [ ] https://www.nowcoder.com/discuss/225303
- [ ] https://www.nowcoder.com/discuss/225338
- [ ] https://www.nowcoder.com/discuss/225847
- [ ] https://www.nowcoder.com/discuss/226040
- [ ] https://www.nowcoder.com/discuss/226387
- [ ] https://www.nowcoder.com/discuss/226787
- [ ] https://www.nowcoder.com/discuss/227697
- [ ] https://www.nowcoder.com/discuss/229399
- [ ] https://www.nowcoder.com/discuss/229534
- [ ] https://www.nowcoder.com/discuss/231456
- [ ] https://www.nowcoder.com/discuss/231761
- [ ] https://www.nowcoder.com/discuss/232309
- [ ] https://www.nowcoder.com/discuss/237428
- [ ] https://www.nowcoder.com/discuss/239036
- [ ] https://www.nowcoder.com/discuss/242361
- [ ] https://www.nowcoder.com/discuss/243039
- [ ] https://www.nowcoder.com/discuss/244860
- [ ] https://www.nowcoder.com/discuss/245484
- [ ] https://www.nowcoder.com/discuss/247261
- [ ] https://www.nowcoder.com/discuss/248717
- [ ] https://www.nowcoder.com/discuss/252402
- [ ] https://www.nowcoder.com/discuss/252571
- [ ] https://www.nowcoder.com/discuss/253206
- [ ] https://www.nowcoder.com/discuss/253283
- [ ] https://www.nowcoder.com/discuss/261051
- [ ] https://www.nowcoder.com/discuss/261335
- [ ] https://www.nowcoder.com/discuss/270779
- [ ] https://www.nowcoder.com/discuss/273138
- [ ] https://www.nowcoder.com/discuss/287688
- [ ] https://www.nowcoder.com/discuss/289454
- [ ] https://www.nowcoder.com/discuss/290452
- [ ] https://www.nowcoder.com/discuss/366421
- [ ] https://www.nowcoder.com/discuss/382253
- [ ] https://www.nowcoder.com/discuss/388111
- [ ] https://www.nowcoder.com/discuss/393334
- [ ] https://www.nowcoder.com/discuss/393898
- [ ] https://www.nowcoder.com/discuss/394274
- [ ] https://www.nowcoder.com/discuss/394718
- [ ] https://www.nowcoder.com/discuss/411644